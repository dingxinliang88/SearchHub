INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (1, 'ParallelStream的坑', 'Java 8引入了Stream API，使得处理集合数据更加方便和高效。其中，ParallelStream是一个并行的Stream，能够在多个CPU核心上并行处理数据。\n\n然而，在使用ParallelStream时有一些需要注意的坑：\n\n1. 数据竞争：由于并行处理数据会涉及到多线程操作，所以可能会出现数据竞争的问题。这可能导致计算结果不正确或者性能下降。要避免这个问题，可以使用synchronized关键字或者ConcurrentHashMap等并发容器。\n\n2. 并行度设置：默认情况下，ParallelStream会根据CPU核心数动态调整并行度。但是，如果数据量较小，设置过高的并行度反而会降低性能。可以通过System.setProperty(\"java.util.concurrent.ForkJoinPool.common.parallelism\", \"n\")来手动设置并行度，其中n为期望的并行度值。\n\n3. 管道操作顺序：在执行管道操作时，需要注意操作顺序对最终结果的影响。例如，map操作可以在并行流中并行处理，而reduce操作则必须在所有元素都处理完毕后再进行汇总。因此，在设计管道操作时需要考虑操作的顺序和相互之间的依赖关系。\n\n4. 状态变量：在并行处理数据时，需要避免使用共享状态变量，因为多个线程同时访问会导致数据竞争问题。可以使用Stream.collect()方法来汇总并行处理的结果，而不是在并行流中进行状态变量的修改。\n\n5. 任务分配：ParallelStream采用Fork/Join框架来实现任务分配。但如果其中一个任务执行时间过长或者出现异常，整个流的性能可能会受到影响。可以通过设置合适的阈值和错误处理机制来避免这个问题。\n\n总之，在使用ParallelStream时需要认真考虑数据竞争、并行度设置、管道操作顺序、状态变量和任务分配等因素，以确保得到正确的结果和最优的性能。', '2023-06-02 19:39:16', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (2, '如何学习编程', '学习编程需要掌握基本的编程概念和语法，建议从简单的编程语言入手，例如Python、Java等。此外，要善于利用搜索引擎和在线教程来加速学习进程。', '2022-02-14 15:30:45', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (3, '如何保持身体健康', '保持身体健康需要注意饮食、运动和休息等方面。应该远离高脂肪、高热量的食物，多吃水果和蔬菜；适当参加有氧运动，比如慢跑、游泳等；每天保证充足的睡眠时间。', '2022-03-21 12:45:12', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (4, '如何提高工作效率', '提高工作效率需要合理安排时间、避免分心、学会使用工具等。可以根据自己的工作情况制定详细的计划表，把任务分解成小步骤，并逐一完成；在工作期间专注于当前任务，避免无关事务的干扰；利用一些辅助工具，例如时间管理软件、任务清单等。', '2022-04-03 09:15:37', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (5, '如何学好英语', '学好英语需要多听、多说、多读、多写。可以通过听力材料、口语练习、阅读材料和写作练习来提高自己的英语水平。此外，还可以参加英语培训班或者找到一个英语母语人士进行交流。', '2022-05-08 18:20:02', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (6, '如何养成良好作息习惯', '养成良好作息习惯需要定时吃饭、定时睡觉、适量运动等。应该按时吃早、中、晚三餐，不要贪吃或节食；保证每天有充足的睡眠时间，尽量在晚上10点前入睡；适当进行户外活动，保持身体健康。', '2022-06-17 07:55:28', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (7, '如何处理人际关系', '处理人际关系需要注意沟通、尊重和包容。应该尽可能与他人进行交流，了解彼此的需求和想法；尊重他人的个性和权利，不要强加自己的意志；对于他人的过失或错误应该采取包容和宽容的态度。', '2022-07-22 14:10:53', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (8, '如何学好数学', '学好数学需要掌握基本概念和方法，注重理论和实际结合。可以通过课堂听讲、课后练习、参考资料等方式来提高自己的数学水平；在学习过程中应该注重理论和实际的结合，掌握数学知识的应用方法。', '2022-09-01 11:40:19', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (9, 'Java多线程编程', 'Java多线程编程是一项非常重要的技能，在开发高并发应用时很有用。本教程从基础概念到实际应用都有讲解，并提供了丰富的示例代码。学完后，您将掌握Java多线程编程的核心知识和应用方法，可以轻松开发出高效、稳定、安全的多线程应用。', '2023-06-02 20:29:38', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (10, 'Python数据分析与机器学习', 'Python是目前最流行的编程语言之一，尤其在数据分析和机器学习领域。本教程将为您详细介绍Python数据分析和机器学习的基础知识和高级技能。您将学会使用Python处理和分析各种数据类型，如数字、日期、文本和图像等。同时，您还将学会使用Python构建各种机器学习模型，并将它们应用于实际场景。学完本教程后，您将成为一名Python数据分析和机器学习的专家。', '2023-06-02 20:29:38', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (11, 'JSONP解决跨域', '\nJSONP(JSON with Padding)是继绝跨域问题的古老方案。同源策略中，对标签的跨域请求限制较小。JSONP利用了这一点。\n\n步骤：\n\n- 准备一个回调函数\n- 服务器响应时返回的是执行该函数的js代码，将需要返回的数据作为该函数的参数\n\n跨域情况下发起AJAX请求：\n\n前端服务在5000端口：\n\n```html\n  <button type=\"\" onclick=\"request()\">get</button>\n  <script>\n    function callback(data) {\n      console.log(data);\n    }\n\n    function request() {\n      fetch(\'http://localhost:8000/data\').then((res) => {\n        console.log(res);\n      })\n    }\n  </script>\n```\n\n后端服务在8000端口：\n\n```js\nconst http = require(\"http\");\n\n\nconst server = http.createServer(function(req,res){\n\n});\n\nserver.on(\'request\',function(req,res){\n\n	const url = req.url;\n	const data = [{\n	  name:\'shao\',\n	  age:18},\n	  {\n	   name:\'clean\',\n	  age:20}\n	];\n	if(url === \'/\'){\n		res.end(\'hello world\');\n	}\n	\n	if(url === \'/data\'){\n    //返回一个函数，函数的参数是需要传递的数据\n		res.end(`callback(${JSON.stringify(data)})`); \n	}\n\n})\n\nserver.listen(8000,function(){\n  console.log(\"服务器运行在8000端口\")\n})\n```\n\n会报跨域的错误。\n\n使用JSONP方式解决：\n\n```html\n<button type=\"\" onclick=\"request()\">get</button>\n<script>\n  function callback(data) {\n    console.log(data);\n  }\n\n  function request() {\n    const script = document.createElement(\'script\');\n    script.src = \'http://localhost:8000/data\';\n    document.body.appendChild(script);\n  }\n</script>\n```\n\n\n\n成功解决了之前的跨域报错，获取到数据\n\n![image-20221222144237536](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/7374/image-20221222144237536.png)', '2023-06-03 19:19:11', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (12, 'React 新文档学习 - 起步模块笔记', '\n### React 新文档 - 起步 快速入门笔记\n\n我们只需要按照官方文章从上往下阅读即可，新文档对刚刚接触编程的真的很友好！\n\n### 知识点\n\n1. 在 JSX 中，`<> </>` 标签，等同于 `React.Fragment` , `React.Fragment` 是一个轻量级的容器, 它用于包裹一组子元素而不添加额外的 DOM 节点。换句话说，它允许你返回多个元素而无需使用一个额外的外层容器（如 <div> 或 <span>）。\n2. 在 JSX 中必须闭合标签，并且将它们包裹到一个共享的父级\n3. 在 JSX 中，我们通过 `classname` 添加样式，使用 `{}` 包裹变量或者说是状态，甚至更复杂的表达式\n4. 在 JSX 中，我们可以通过 `style={{}}` 来进行添加行内样式，这并不是特殊写法，是 `{}` 包裹一个普通的对象，对象值为 css 样式\n5. 使用 `if` 进行条件渲染，使用 `map` 进行遍历，但是我们需要添加 `key` 进行对相同元素进行唯一标识此元素，因为 React 依赖这个进行更新 DOM\n6. 使用 `onClick` 声明事件处理函数；进行交互，例如：`onClick={handleClick}` ,我们不需要在方法名后添加 `()` ,\n7. React 的 Hooks 是 React 的核心，我们最常使用的就是 useState，useEffect，前者声明状态，后者处理副作用；它们与一个普通变量的区别就是它们的更新可能会触发页面DOM的更新，我记得我最初学习的时候，纠结了很久为什么以`use`开头的被称为 `Hooks` ，其实这个就是约定的，没有理由，我们在通过内置 `Hooks` 写自己的 `Hooks` 的时候，其实是可以不以 `use` 开头的，但是，我们的代码是要方便更多人阅读的，所以我们需要一个统一的约定，那 `use` 开头就是 React 中的 `Hooks` ，这就是一个 React 开发者之间的友好的约定，帮助别人阅读你的代码\n8. 官方的这个 demo ：https://codesandbox.io/s/1ghtss?file=/App.js&utm_medium=sandpack，它还告诉了我们 React 的每个组件都形成了一个闭包，变量不会污染，\n9. React 组件间的信息传递，父传子通过 `prop`  ,\n\n### 小细节\n\n1. React创建的是一个单页面程序，我们所有写的都是组件，我们就像一个建筑工人，写出我们需要的不同的砖块，然后通过不同的方式摆放砖块，实现我们想要的页面和交互\n2. 每讲完一个知识点，都会有对应的最小 demo ，我们可以通过实际的代码，更加直观的感受技术的使用场景和相比较原生开发的优势\n3. 新的官方文档，所有都是采用 函数组件 和 Hooks 进行代码编写，也是正式丢弃了 类组件 和 this 的写法，\n4. 通过 **状态提升** 我们可以实现组件间数据共享，但是这里的缺点就是，共享数据的两个组件必须在同一个父组件中，如果不在同一个父组件那怎么办呢？\n\n### 快速入门 - Tic - Tac - Toe 游戏\n\n> 简介：通过一个小游戏，更加深入的理解 React 这个库，但是这个小游戏的开发没有使用到 React 的所有知识，\n\n这里 Dan 大神细心的告诉我们，这节是给那些喜欢边做边学并希望快速尝试制作有形东西的人而设计，如果您喜欢逐步学习每个概念，请从 <u>描述 UI</u> ：https://zh-hans.react.dev/learn/describing-the-ui开始。\n\n通过这个游戏，我们会收获：\n\n1. React中最常用的知识，\n2. 函数组件和组件化思维\n3. 如何在 codeSandbox 中快速构建我们的应用\n\n#### 制作这个小游戏的过程\n\n> 强烈建议通过新文档 + codeSandbox 自己跟着做，帮助查漏补缺，文档中强调了很多新手会忽略的细节，例如：组件首字母大写，{} 渲染动态数据等等，演示了很多因为粗心可能会犯的错误，他甚至连如何打开控制台都告诉我们，太细心了，如果你是编程小白，这真的太赞了\n\n1. 先去使用 codeSandbox ，创建一个按钮组件\n2. 使用index.js进行链接样式和DOM\n3. 一个组件下面只能只能有一个根元素\n4. 使用 css 进行样式修改\n5. 通过props传递数据，实现组件数据按需显示\n6. 使用 useState 进行状态更新\n7. 交替显示按钮值，并且确定游戏胜利规则\n\n#### 知识点\n\n1. **组件：**在 React 中，组件是代表用户界面一部分的一段可重用代码。组件用于呈现、管理和更新应用程序中的 UI 元素。\n\n2. 携带参数的事件。\n\n   1. 错误写法：`<Square value={squares[0]} onSquareClick={handleClick(0)} />`\n   2. 正确写法：`<Square value={squares[0]} onSquareClick={() => handleClick(0)} />` \n\n3. 一个自定义DOM，经常可以使用 handleSomething 来处理自定义事件\n\n4. 我们应该保持数据的不变性。这个需要理解：\n\n   1. 在深入了解为什么不可变性在React中很重要之前，让我们先了解一下可变性（Mutability）和不可变性（Immutability）的概念。可变性（Mutability）是指一个对象在创建之后，其状态和属性可以被改变。与之相反，不可变性（Immutability）是指一个对象在创建之后，其状态和属性不能被改变。\n\n      那么，为什么React中的不可变性如此重要呢？这主要有以下几个原因：\n\n      1. 状态跟踪：不可变性使得我们能够更容易地追踪组件状态的变化。当状态发生变化时，我们可以通过创建一个全新的对象（而不是直接修改现有对象）来表示新状态。这样一来，我们可以清晰地看到状态是如何从一个状态过渡到另一个状态的。\n\n      2. 性能优化：React使用不可变数据可以带来性能优化。在React中，当组件的状态或属性发生变化时，会触发重新渲染。不过，有时重新渲染并不是必要的。通过使用不可变数据，我们可以方便地比较前后状态，从而避免不必要的渲染。\n\n      3. 简化代码：不可变数据有助于简化代码。由于状态和属性不能被直接修改，我们不需要担心某个变量在函数间被意外地修改。这使得我们的代码更加可靠和可预测。\n\n      4. 举个例子，假设我们有一个待办事项列表的应用程序，每个待办事项有一个标题和一个完成状态。当我们想要改变一个待办事项的完成状态时，我们可以使用不可变数据，如下所示：\n\n      5. ```js\n         // 原始的待办事项数组\n         const todos = [\n           { title: \"Buy groceries\", completed: false },\n           { title: \"Clean the house\", completed: false },\n         ];\n         \n         // 修改第一个待办事项的完成状态\n         const updatedTodos = todos.map((todo, index) =>\n           index === 0 ? { ...todo, completed: !todo.completed } : todo\n         );\n         \n         console.log(todos);\n         console.log(updatedTodos);\n         ```\n\n      6. 在上面的例子中，我们没有直接修改原始的`todos`数组，而是创建了一个新的`updatedTodos`数组。这使得我们可以清晰地看到`todos`和`updatedTodos`之间的区别，也有助于避免不必要的渲染。\n\n#### END\n\nDAN大神真的很会写文章，它在完成游戏功能后，说道：”恭喜！您现在有一个可以运行的井字游戏。你也刚刚学习了 React 的基础知识。所以你是这里真正的赢家。“，他还给我们布置了作业，真的不错！如果你英语不是很好，有一个Google插件可以帮助学习：**Mate Translate** \n\n### React构建应用的思维\n\n> React 可以改变您对所看到的设计和构建的应用程序的看法。当您使用 React 构建用户界面时，您首先会将其分解为不同的组件。然后，您将描述每个组件的不同视觉状态。最后，您会将组件连接在一起，以便数据流经它们。在本教程中，我们将引导您完成使用 React 构建可搜索产品数据表的思考过程。\n\n这里同样是一个React demo来进行理解学习，要做的是一个支持搜索的列表，如果我们要做出一个这样的功能，我们需要遵循以下几步：\n\n1. 将 UI 分解为组件层次结构\n2. 在 React 中构建一个静态版本（**此时，您不应使用任何状态值。这是下一步！**）\n3. 找到最小但完整的 UI 状态表示，这里是告诉我们应该声明最少的状态，完成我们的功能，在这个例子中很明显的让我们看到了哪些状态是不需要去声明的，是可以通过计算得出的\n4. 难点来了，我们应该如何分配我们的状态 **state** 给到 对应的组件 **component**，\n5. 添加反向数据流；这里的意思是子组件像父组件传输数据或者信号\n\n#### END\n\nThinking in React 这一章虽然简单，但是，这就是React开发的核心思想，我们在后面的 Learn REACT 也能看到，先描述 UI ，再添加交互，然后去管理我们的状态，最后给我们讲了一下，如何去处理一些特殊的场景\n\n\n\n最后，如果你是一名打算学习 React 的人，那 React 新文档就是最好的文字教程，这个文章仅仅记录了我觉得我需要加深理解的地方，如果想要系统学习，需要去看并且跟着做demo项目：https://react.dev/learn\n\n', '2023-06-03 19:19:11', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (13, 'React 新官方文档，重新系统学习 React', '\n这是一篇介绍React新官方文档的文章，\n\n1. 中文文档地址（新）：https://zh-hans.reactjs.org/，\n2. 英文地址（新）：https://react.dev/\n3. 中文文档地址（旧）：https://reactjs-old.bootcss.com/\n4. 英文地址（旧）：https://legacy.reactjs.org/\n\n新的官方文档是由 Dan 大神主导编写的，所有先了解一下 Dan Abramov。Dan Abramov 是一位著名的 JavaScript 开发者和 React 领域的专家。他是 Redux 库的共同创建者之一，该库被广泛用于管理 React 应用程序的状态。Dan 还是 React 团队的核心成员，曾为 React 官方文档和社区作出巨大贡献。他的博客分享了很多有关 React 和前端开发的见解和技巧。他的  blog 地址：https://overreacted.io/，他的GitHub：https://github.com/gaearon 有81.5k的 followers 。没错，下面就是我们帅气的 Dan：\n\n![gaearon](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/gaearon.webp)\n\n接下来我们跟着新的官方文档学习一下React框架！\n\n首先，先看下首页，我们对比一下，新旧文档的首页，可以了解到React框架的发展变化。\n\n新官方首页：\n\n![image-20230418084323194](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230418084323194.png)\n\n旧官网首页：\n\n![image-20230418084136762](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230418084136762.png)\n\n总结一下：\n\n1. 看以看到新的官网首页，更加的简洁，\n2. 新的官方header部分，有以下几个功能\n   1. 经典的图标（回到主页面）和搜索，但是搜索占的体积增大，代表我们可以通过搜索快速精确查找到我们想要的内容\n   2. 往右侧就是分为四个模块，分别为系统学习模块 Learn ，快速查找 Reference，社区模块 Community和 官方动态 Blog，\n   3. 还贴心的新增了暗黑模式给夜猫子\n3. 新的官网说：用于构建 Web 和原生交互的库，这里删除了 JavaScript ，那 React 是要用Rust 写吗？还有现在添加了原生交互，说明 React 团队对 React 框架在交互上面做的也非常好了\n4. 往下看，新的官方介绍了 React 框架的特点，\n   1. 组件化；\n   2. 函数组件；\n   3. 响应式；\n   4. 强调他们是一个库，而不是框架，因为它不像Vue，提供了非常多的能力，它说自己也是一种架构（此处需要后面学习印证），\n   5. 跨端框架，即可开发 Web，也可以开发原生应用\n   6. 每一个改动都验证在了大数据的页面，可以方向使用\n   7. 加入React社区\n\n相比较旧的官方，新的官网在介绍 React 能力的时候，会写一个小的 demo ，更加方便，直观的去帮助学习者理解和吸收知识\n\n主页模块就看完了，下期跟着官方文档的 Learn 模块学习 React ！\n\n', '2023-06-03 19:19:11', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (14, '极简 Nginx 学习 + 使用，点到为止', '## 极简Nginx学习 + 使用\n\n​	最近工作中，遇到了需要使用 nginx 的场景，但是我又从来没有学习使用过，于是打算系统的学习使用一下，填补一下自己的「 **知识坑** 」\n\n**下面所有操作都是在 windows 上，如果 mac 可能会不一致**\n\n​	对于这种必备的技术栈，可以去 Github 上面搜索一下相关教程，Nginx 在 Github 上有一个3.5k star 的文字教程，于是，我就打算使用这个教程 + chatGPT 学习一下这个新的知识，\n\n​	参考资料：\n\n1. Nginx 极简教程 ：https://github.com/dunwu/nginx-tutorial\n\n​	我的学习目标\n\n1. 知道什么是 Nginx？它的作用？\n2. 知道如何使用 Nginx？Nginx 有哪些使用场景？\n3. 体验 Nginx ，写 demo\n\n### 什么是 Nginx ？\n\n**Nginx (engine x)** 是一款轻量级的 Web 服务器 、反向代理服务器及电子邮件（IMAP/POP3）代理服务器。分析一下这句话：\n\n- 是一个 WEB 服务器，\n- 特点：很轻量，能够反向代理和电子邮件代理\n\n这里有几个概念需要理解：\n\n#### 服务器和 WEB 服务器的区别\n\n- Web服务器是一种计算机程序，它提供了从网页到客户端的传输协议。它的作用是接收来自客户端的HTTP请求，并向客户端返回HTTP响应，以此来提供Web服务。\n- 服务器是指一种计算机系统，它能够处理来自客户端的请求，并提供相应的服务。服务器可以运行各种不同的软件和应用程序，包括Web服务器、邮件服务器、数据库服务器等等。Web服务器是服务器的一种，它特别针对Web应用程序而设计，提供HTTP协议的支持。\n\n因此，Web服务器是服务器（的子集）的一种特定类型，它专门用于提供Web服务。\n\n#### 什么是反向代理\n\n我自己理解的一句话：正向代理，代理的是客户端，例如：VPN，反向代理代理的是服务端：例如：Web 服务器负载均衡，安全访问内部应用（使用 Nginx 作为反向代理服务器，让用户通过外部 URL 访问企业内部的应用程序，例如 GitLab 或者 Jenkins 等。）\n\n反向代理（Reverse Proxy）方式是指以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给 internet 上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n![image-20230429175745516](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230429175745516.png)\n\n分析一下上面这张图，可以看到 nginx 可以帮助我们链接客户端和服务端，它提供了很多的能力，帮我们封装了很多客户和服务端通信的能力\n\n### Nginx 实战\n\n#### （1）nginx 初体验\n\n1> 下载： https://github.com/dunwu/nginx-tutorial/blob/master/docs/nginx-ops.md\n\n2> 运行：进入下载的 nginx 目录 输入 nginx ，或者运行目录下的 nginx.exe\n\n> 运行成功后，可看到\n\n![image-20230429182714665](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230429182714665.png)\n\n3> 停止运行：可以使用`nginx -s stop`，这里需要注意，一台电脑可以同时启动多少 nginx 服务，可以使用`tasklist /fi \"imagename eq nginx.exe\"`关闭所有的 nginx ，还有，重启计算机不会直接关闭正在运行的 Nginx 进程。当您重启计算机时，操作系统将会先关闭所有进程，包括 Nginx 进程。但是，在关闭 Nginx 进程之前，操作系统会先向 Nginx 进程发送一个关闭信号，等待 Nginx 进程结束，确保所有数据都已经保存。当您重新启动计算机后，如果您已经正确地配置了 Nginx 的自动启动，那么它将在计算机启动后自动运行。\n\n**nginx**常用命令：\n\n```bash\nnginx -s stop       快速关闭Nginx，可能不保存相关信息，并迅速终止web服务。\nnginx -s quit       平稳关闭Nginx，保存相关信息，有安排的结束web服务。\nnginx -s reload     因改变了Nginx相关配置，需要重新加载配置而重载。\nnginx -s reopen     重新打开日志文件。\nnginx -c filename   为 Nginx 指定一个配置文件，来代替缺省的。\nnginx -t            不运行，仅仅测试配置文件。nginx 将检查配置文件的语法的正确性，并尝试打开配置文件中所引用到的文件。\nnginx -v            显示 nginx 的版本。\nnginx -V            显示 nginx 的版本，编译器版本和配置参数。\n```\n\n如果不想每次都敲命令，可以在 nginx 安装目录下新添一个启动批处理文件**startup.bat**，双击即可运行。内容如下：\n\n```bash\n@echo off\nrem 如果启动前已经启动nginx并记录下pid文件，会kill指定进程\nnginx.exe -s stop\n\nrem 测试配置文件语法正确性\nnginx.exe -t -c conf/nginx.conf\n\nrem 显示版本信息\nnginx.exe -v\n\nrem 按照指定配置去启动nginx\nnginx.exe -c conf/nginx.conf\n```\n\n#### （2）我们最熟悉的文件：nginx.conf\n\n在开发、测试环境下，我们都得自己去配置Nginx，就是去配置nginx.conf。nginx.conf是典型的分段配置文件，下面我们来分析下面的 nginx 配置（宝塔面板的）\n\n```yaml\nserver\n{\n    listen 80;\n    server_name pt.xdr630.top;\n    index index.php index.html index.htm default.php default.htm default.html;\n    root /www/wwwroot/pt.xdr630.top;\n    \n    #SSL-START SSL相关配置，请勿删除或修改下一行带注释的404规则\n    #error_page 404/404.html;\n    #SSL-END\n    \n    #ERROR-PAGE-START  错误页配置，可以注释、删除或修改\n    error_page 404 /404.html;\n    error_page 502 /502.html;\n    #ERROR-PAGE-END\n    \n    #PHP-INFO-START  PHP引用配置，可以注释或修改\n    include enable-php-72.conf;\n    #PHP-INFO-END\n    \n    #REWRITE-START URL重写规则引用,修改后将导致面板设置的伪静态规则失效\n    include /www/server/panel/vhost/rewrite/pt.yunxdr.top.conf;\n    #REWRITE-END\n    \n    #禁止访问的文件或目录\n    location ~ ^/(\\.user.ini|\\.htaccess|\\.git|\\.svn|\\.project|LICENSE|README.md)\n    {\n        return 404;\n    }\n    \n    #一键申请SSL证书验证目录相关设置\n    location ~ \\.well-known{\n        allow all;\n    }\n    \n    location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$\n    {\n        expires      30d;\n        error_log off;\n        access_log /dev/null;\n    }\n    \n    location ~ .*\\.(js|css)?$\n    {\n        expires      12h;\n        error_log off;\n        access_log /dev/null; \n    }\n    access_log  /www/wwwlogs/pt.yunxdr.top.log;\n    error_log  /www/wwwlogs/pt.yunxdr.top.error.log;\n}\n```\n\n1. **listen 80;** 指令表示监听 80 端口，当有请求发送到该端口时，Nginx 将根据配置块中的 server_name 进行请求路由。\n2. **server_name pt.xdr630.top;** 指令表示虚拟主机的域名为 pt.xdr630.top，当有请求发送到该域名时，Nginx 将会处理该请求。\n3. **index index.php index.html index.htm default.php default.htm default.html** 指令表示默认文档列表。当客户端请求的 URL 中未指定文件名时，Nginx 将按照这个顺序寻找默认文档，直到找到为止。\n4. **root /www/wwwroot/pt.xdr630.top** 指令表示该虚拟主机的网站根目录为 /www/wwwroot/pt.xdr630.top。\n5. **location ~ ^/(\\.user.ini|\\.htaccess|\\.git|\\.svn|\\.project|LICENSE|README.md)** 指令表示禁止访问这些文件或目录，当客户端请求这些文件或目录时，Nginx 将返回 404 错误。\n6. **location ~ \\.well-known{ allow all; }** 指令表示允许所有的客户端访问以 .well-known 开头的路径，例如 /well-known/acme-challenge。\n7. **location ^~ /** 表示所有请求都将匹配到该 location 块中。^~ 表示开头匹配，不会被正则表达式覆盖。/ 表示匹配所有请求。\n8. **location ~ .*\\.(gif|jpg|jpeg|png|bmp|swf)$** 指令表示对于以 gif、jpg、jpeg、png、bmp 和 swf 结尾的请求，Nginx 将启用浏览器缓存，并禁用 error_log，并将访问日志写入 /dev/null。\n9. **location ~ .*\\.(js|css)?$** 指令表示对于以 js 和 css 结尾的请求，Nginx 将启用 12 小时的浏览器缓存，并禁用 error_log，并将访问日志写入 /dev/null。\n10. **access_log** 和 **error_log** 指令用于配置访问日志和错误日志的存储位置。在这个例子中，访问日志存储在 /www/wwwlogs/pt.yunxdr.top.log，错误日志存储在 /www/wwwlogs/pt.yunxdr.top.error.log。\n\n2. **proxy_pass** 指令设置了反向代理的目标地址，即 http://passport.csdn.net。在这个例子中，Nginx 会将所有匹配到该 location 块的请求转发到 http://passport.csdn.net。\n3. **proxy_set_header** 指令用于设置请求头。其中，Host 设置代理目标的 Host 头，X-Real-IP 设置客户端的真实 IP 地址，X-Forwarded-For 设置客户端的 IP 地址，REMOTE-HOST 设置客户端的 IP 地址。这些头信息可以让代理目标服务器了解客户端的真实情况。\n4. **add_header X-Cache $upstream_cache_status** 指令用于在响应头中添加一个名为 X-Cache 的头信息。$upstream_cache_status 表示代理缓存的状态。\n5. **if ( $uri ~* \"\\.(gif|png|jpg|css|js|woff|woff2)$\" ) { }** 表示对于某些特定的静态资源，不使用代理缓存。这些资源的文件扩展名包括 gif、png、jpg、css、js、woff 和 woff2。\n6. **proxy_ignore_headers Set-Cookie Cache-Control expires** 指令用于忽略来自代理目标服务器的某些响应头信息。在这个例子中，被忽略的头信息包括 Set-Cookie、Cache-Control 和 expires。\n7. **proxy_cache** 指令用于启用 Nginx 缓存。这个例子中使用的是名为 cache_one 的缓存区。\n8. **proxy_cache_key $host$uri$is_args$args** 指令用于设置缓存键值。缓存键值的组成包括 $host、$uri、$is_args 和 $args 四个变量。其中，$host 表示主机名，$uri 表示请求的 URI，$is_args 表示是否带参数，$args 表示请求参数。\n9. **proxy_cache_valid 200 304 301 302 1m** 指令用于设置缓存的有效期。在这个例子中，200、304、301 和 302 表示缓存的状态码，1m 表示缓存时间为 1 分钟。\n\n该配置文件片段使用了 Nginx 的多个模块和指令，包括\n\n- 监听端口、\n- 虚拟主机、\n- 默认文档列表、\n- 访问控制、\n- 浏览器缓存、\n- 访问日志和错误日志，\n- 反向代理和缓存功能，可以提高 Web 服务器的性能和可用性，并提供更好的用户体验。\n\nNginx 还有很多知识需要去学习，但是我现在应该用不到，如果学习不使用很快就会忘记，所有等我使用的时候再看文档：https://docs.nginx.com/\n\n\n\n其实我们部署静态网页只需要配置下面几个参数即可：\n\n```yaml\nserver\n{\n    listen 80;\n    server_name pt.xdr630.top;\n    index index.php index.html index.htm default.php default.htm default.html;\n    root /www/wwwroot/pt.xdr630.top;\n }\n```\n\n\n\n### Nginx的一些问题？\n\n1. Nginx如何做到热部署？\n\n> 所谓热部署，就是配置文件nginx.conf修改后，不需要stop Nginx，不需要中断请求，就能让配置文件生效！（nginx -s reload 重新加载 /nginx -t检查配置 /nginx -s stop 快速关闭 nginx ）\n\n答：修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可。\n\n2. 为什么要用Nginx？\n3. 为什么Nginx性能这么高？\n4. Nginx是如何实现高并发的？\n5. Nginx是如何处理一个请求的呢？\n\n以上请看：https://cloud.tencent.com/developer/article/1499521\n\n6. Nginx如何做到高并发下的高效处理？\n7. Nginx挂了怎么办？\n8. Nginx如何做到高并发下的高效处理？\n\n以上请看：https://www.zhihu.com/search?type=content&q=nginx%20\n\n### 参考\n\n1. 前端必备知识之 Nginx ：https://juejin.cn/post/7108394145068089374\n2. 前端 nginx 之路：https://zhuanlan.zhihu.com/p/458905411\n3. nginx 下载安装，启动，关闭：https://juejin.cn/post/7000907531191058468\n4. 8分钟学习 nginx ：https://www.zhihu.com/search?type=content&q=nginx%20\n\n通过学习，我基本知道了 nginx 的作用，nginx.conf 的一些常用参数的含义，如何配置该文件， ', '2023-06-03 19:19:11', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (15, 'coderwhy的vue3课程笔记-组件化开发', '#### 父子组件间的通信\n\n- 父组件 => 子组件 ：通过`props`属性\n- 子组件 => 父组件： 通过`$emit`触发事件\n\n##### 父传子\n\n我们可以通过`props`来完成组件之间的通信\n\n###### props是什么？\n\n- props是你可以在组件上`注册一些自定义的attribute`\n- 父组件可以给`这些attribute赋值`，子组件通过`attribute的名称`获取到对应的值\n\n###### props有两种常见的用法：\n\n- 方式一：字符串数组，数组中的字符串就是attribute的名称\n- 方拾二：对象类型；对象类型我们可以在指定props名称的同时，指定它需要传递的类型，是否是必须的，默认值\n\n**props的数组用法**\n\n```vue\n//子组件-showMessage\n<template>\n	<div>组件展示的title:{{title}}</div>\n	<div>组件展示的content:{{content}}</div>\n</template>\n<script>\n  export default {\n  	props:[\"title\", \"content\"]\n  }\n</script>\n// 父组件\n<template>\n	<div>\n    <show-message title=\"heihei\" content=\"this is a boring boy\">\n    </show-message>\n  </div>\n</template>\n```\n\n**props的对象用法**\n\n数组用法只能传入attribute的名称，并不能对形式做限制和传入默认值\n\n- 指定传入的`attribute的类型`\n- 指定传入的`attribute是否是必传的`\n- 指定没有传入时，`attribute的默认值`\n\n```vue\nexport default {\n	props:{\n		//指定类型\n	title: String,\n//指定类型 同时指定是否必选，默认值\ncontent: {\n	type: String,\n	require: true,\n	default:\"哈哈哈\"\n}\n	}\n}\n```\n\n**对象类型的其他写法**\n\n```vue\nprops: {\nmsg: String,\n// 基础类型检查（null 和 undefined 会通过任何类型检测）\npropA: [String, Number],\n//可能多个类型\npropB: {type: String, require: true}\n//必填\npropC：{type: Number, default:100 }\n// 带有默认值的数字\npropD:{\n	type: Object,\n	default() { return { message:\'hello\' } }\n}\n}\n//带有默认值的对象\npropE:{\n	validator(value) {\n	//这个值必须 匹配下面字符串中的一个\nreturn [\'success\', \'denger\', \'error\'].includes(value)\n}\n}\n// 自定义验证函数\npropF:{\n	type:Function,\n	// 与对象或函数默认值不同，这不是一个工厂函数\n	default() {\n	return \'Default Function\'\n	}\n}\n```\n\n**非Prop的Attribute**\n\n**当我们**`**传递给一个组件某个属性**`但是`该属性没有定义对应的props或者emits`时，就称之为`非props的Attribute`\n\n例如常见的：`class`,`style`,`id`\n\n**Attribute继承**\n\n当组件有单个根节点时，非Prop的Attribute将自动添加到根节点的Attribute中\n\n**禁用Attribute继承和多根节点**\n\n如果我们不希望组件的根元素继承attribute，可以在组件中设置`inheritAttrs:false`\n\n **我们可以通过$attrs来访问所有的 非props的attribute**\n\n##### 子传父\n\n###### 前置知识\n\n- **emits**\n\nemits可以是数组或者对象，从组件触发自定义事件，对象可以进行参数验证\n\n###### 如何实现\n\n- 首先，我们需要在**子组件中定义好在某些情况下触发的事件名称**；\n- 其次，在**父组件中以v-on的方式传入要监听的事件名称**，并绑定到对应的方法中\n- 最后在子组件中发生某个事件的时候，根据事件名称触发对应的事件\n\n```vue\n// 父组件\n<h2>当前计数: {{counter}}</h2>\n<counter-operation @add=\"addOne\"></counter-operation>\n<script>\n  data() {\n  return {\n    counter: 0\n  }\n},\nmethods: {\n  addOne() {\n    this.counter++\n  }\n}\n\n// 子组件\n<button @click=\"increment\">+1</button>\nemits: {\n	add: null,\n},\ndata() {\n  return {\n    num: 0\n  }\n},\nmethods: {\n  increment() {\n    console.log(\"+1\");\n    this.$emit(\"add\");\n  },\n  incrementN() {\n    const flag = this.$emit(\'addN\', this.num, \"why\", 18);\n    console.log(flag,\'flag\');\n  }\n}\n</script>\n```\n\n###### 自定义事件\n\n自定义事件我理解的是：子组件传值给父组件的时候，父组件可以自定义事件名称例如`@customName`然后子组件就可以通过`emits`来接收到这个自定义事件并调用它，通过`this.$emits(\"customName\",..args)`args是父组件中的这个自定义事件所需要的参数，可以传多个\n\n##### 非父子组件的通信\n\n在我们实际开发中还有很多非父子组件的通信\n\n###### 主要有两种方式：\n\n- Provide/Inject\n- Mitt全局事件总线\n\n###### Provide和Inject\n\n- 比如有一些**深度嵌套的组件**，**子组件想要获取父组件的部分内容**；\n- 如果我们任然**将props沿着组件链逐级传递下去**，就会非常的麻烦；\n- 对于这种情况，我们可以使用**Provide和Inject:**\n\n- - 无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者\n  - 父组件有一个**provider选项**来提供数据，子组件有一个**inject选项**来开始使用这些数据\n\n- 实际上，你可以将依赖注入看成\'lang range props\' 除了：父组件不需要知道哪些子组件使用它provide的property，子组件不需要知道inject的property来自哪里\n\n\n![1647489120329-5da616df-adb7-44f4-9afb-d38b25988e2a.png](https://pic.code-nav.cn/post_picture/1619930914211520514/oCLwtpzI-1647489120329-5da616df-adb7-44f4-9afb-d38b25988e2a.png)\n\n```vue\n<script>\n  // 父组件\n    provide() {\n      return {\n        name: \"why\",\n        age: 18,\n        length: computed(() => this.names.length) // ref对象 .value\n      }\n    },\n</script>\n<script>\n  // 子组件 ：在子组件中写入后 就可以把它当做data中的数据进行使用\n  export default {\n    inject: [\"name\", \"age\", \"length\"],\n  }\n</script>\n```\n\n###### 全局事件总线`mitt`库\n\nVue3从实例中移除了`$on`、`$off`和`$once`方法，如果我们希望继续使用`全局事件总线` Vue3推荐使用`mitt`库\n\n**不是很理解，不知道实际使用场景**\n\n##### 插槽Slot\n\n###### 使用场景：\n\n在开发中，我们会经常封装一个个可复用的组件：\n\n- 前面我们会通过props传递给组件一些数据，让组件进行展示\n- 但是**为了让组件有更强的通用性**，我们不能将组件的内容限制为**固定的**div，span等等元素\n- 比如某种情况下我们使用组件，希望组件显示的是一个按钮**，换一种情况**组件显示的说一张图片，\n- 我们应该让**使用者可以决定莫一块区域到底存放什么内容和元素**\n\n举个栗子：假如我们定制一个通用的导航组件 -NavBar\n\n- 这个组件分为三个区域，左边 - 中间 - 右边\n- \n- 但是你看，左边可能显示一个菜单图标，也可能显示一个返回按钮，可能还是什么都不显示；中间和右边同理\n\n![1647499195392-e95c87b5-e64f-44ac-a980-02f32a82e6fe.png](https://pic.code-nav.cn/post_picture/1619930914211520514/eQZp7Pi9-1647499195392-e95c87b5-e64f-44ac-a980-02f32a82e6fe.png)\n###### 使用插槽slot\n\n**重要提醒：**\n\n插槽的使用其实就是抽取共性，预留不同；我们将共同的元素，内容依然组件内进行封装；同时将不同的元素使用slot作为占位符，让使用这个组件的实例来定义slot内的内容\n\nvue中将`<slot>`元素作为承载分发内容的出口；在封装组件中，使用特殊的元素<slot>就可以为封装组件开启一个插槽，插槽内的内容完全取决于其实例组件\n\n###### 插槽的默认内容\n\n有时候我们希望在使用插槽时，如果没有对应的内容，那么我们需要显示一个默认的内容，这个默认的内容只会在没有插入内容时候才会显示\n\n```vue\n//使用插槽的组件\n<template>\n  <div>\n    <MySlotCpn>\n    	111                  // 这里的内容就会放到定义好的插槽中，  \n  	</MySlotCpn>\n  </div>\n</template>\n<script>\n  import MySlotCpn from \'./MySlotCpn.vue\';\n  export default {\n    components: {\n      MySlotCpn\n    }\n  }\n</script>\n// 插槽组件\n<template>\n  <div>\n    <slot>\n      <i>我是默认的i元素</i> //当使用这个插槽组件但是没有往插槽中插入任何东西就会显示默认的，否则显示的就是父组件的插入元素\n    </slot>\n  </div>\n</template>\n```\n\n###### 多个插槽效果\n\n如果一个组件中含有多个插槽，但是元素我们插入多个内容，我们会发现每个插槽都会插入所有的内容，为了让内容插到对应的插槽就有了**具名插槽**\n\n**具名插槽就是给插槽起一个名字 <slot>元素就有了一个特殊的attribute：name, 一个不带name的slot会含有隐式的名字default， 它的效果是：**\n\n```vue\n//使用插槽的元素\n<template v-slot:left>\n	this is left\n</template>\n// 插槽 这里slot加载到页面中是没有slot元素的，它只是一个占位符\n<slot name=\"left\"></slot>\n```\n\n###### 动态插槽名\n\n- 目前我们使用的插槽名称都是固定的；例如：v-slot**:left**,这里这个left就是写死的，我们可以通过**v-slot:[dynamicSlotName]**,\n\n```vue\n<template v-slot:[name]>//这个name就是data中定义的动态数据\n</template>\n```\n\n具名插槽的缩写：即把`v-slot:`替换为`#`\n\n##### 渲染作用域\n\n在vue中有渲染作用域的概念：\n\n- 父模板中的所有内容都是在父级作用域中编译；子模板也是一样；其实很好理解；例如我们无法在父模板中访问或者使用子模板的data变量或者方法\n\n##### 作用域插槽\n\n从上面可知，父子作用域独立，但是有时候我们希望**插槽**可以访问到子组件中的内容，这个是很常见的需求\n\n- 当一个组件被用来渲染一个数组元素时，我们使用插槽，并且希望插槽中没有显示每项的内容，这时候就需要作用域插槽\n\n如果还有其他的具名插槽, 那么默认插槽也必须使用template来编写\n\n###### 独占默认插槽的缩写\n\n如果我们的插槽是默认插槽default，那么在使用的时候`v-slot:default=\"slotProps\"`可以简写为`v-slot=\"slotProps\"`\n\n默认插槽和具名插槽混合使用：使用`v-slot:why（一个名称其他也行）`来定义具名插槽，使用`v-slot=\"slotProps\"`来使用默认插槽\n\n##### 动态组件的使用\n\n动态组件是使用component组件，通过特殊的attribute **is**实现\n\n```vue\n<template>\n		<button v-for=\"item in tabs\" :key=\"item\"\n            @click=\"itemClick(item)\"\n            :class=\"{active: currentTab === item}\">\n      {{item}}\n    </button>\n	 <!-- 2.动态组件 -->\n    <keep-alive include=\"home,about,category\" max=\'2\'>\n      <component :is=\"currentTab\"\n                 name=\"coderwhy\"\n                 :age=\"18\"\n                 @pageClick=\"pageClick\">\n      </component>\n    </keep-alive>\n</template>\n<script>\n  data() {\n   return {\n     tabs: [\"home\", \"about\", \"category\"],\n     currentTab: \"home\"\n   }\n },\n methods() {\n   itemClick(item) {\n     this.currentTab = item;\n   },\n   pageClick() {\n     console.log(\"page内部发生了点击\");\n   }\n }\n</script>\n```\n\n##### 认识keep-alive\n\n###### 产生背景\n\n在默认情况下，我们在切换组件时候，about组件会被销毁掉，再次回来时会重新创建组件，但是我们在开发中我们希望继续保持组件的状态，而不是销毁掉，这个时候我们可以使用一个内置组件：keep-alive\n\n###### keep-alive属性\n\n- include ： string | RegExp | Array。只有在名称匹配的组件会被缓存\n- exclude ： string | RegExp | Array。任何匹配的组件都不会被缓存\n- max ： number | string。最多可以缓存多少组实例，一旦达到这个数字，那么缓存中最近没有被访问的实例被销毁\n\n```vue\n  <!-- 2.动态组件 -->\n    <keep-alive include=\"home,about,category\" max=\'2\'>\n      <component :is=\"currentTab\"\n                 name=\"coderwhy\"\n                 :age=\"18\"\n                 @pageClick=\"pageClick\">\n      </component>\n    </keep-alive>\n```\n\n##### 缓存组件的生命周期\n\n对于缓存的组件来说，再次进入时，我们是不会执行created或者mounted等生命周期函数的\n\n- 但是我们有时候希望监听何时重新进入和离开这个组件\n- 这时候我们可以使用`activated`和`deactivated`来监听；\n\n##### vue实现异步组件\n\n###### 1. 产生背景：\n\n当我们项目过大了，对于某些组件我们希望可以通过异步的方式来进行加载（目的是可以对其分包处理，也就是让wabpack对其进行单独打包）\n\n###### 2. 使用\n\nvue给我们提供了一个函数：`defineAsyncComponent` 它接收两种类型参数，\n\n- 工厂函数，该工厂函数需要返回一个`Promise对象`\n- 接收一个对象类型，对异步函数进行配置\n\n```vue\n<script>\n  //工厂函数写法\n  import defineAsyncComponent from \'vue\'\n  const AsyncHome = defineAsyncComponent(()=>import(\"./AsyncHome.vue\"))\n  export default {\n  components: {\n  	AsyncHome\n  }\n  }\n  // 对象写法\n    const AsyncCategory = defineAsyncComponent({\n    loader: () => import(\"./AsyncCategory.vue\"),\n    loadingComponent: Loading,\n    // errorComponent,\n    // 在显示loadingComponent组件之前, 等待多长时间\n    delay: 2000,\n    /**\n     * err: 错误信息,\n     * retry: 函数, 调用retry尝试重新加载\n     * attempts: 记录尝试的次数\n     */\n    onError: function(err, retry, attempts) {\n\n    }\n  })\n</script>\n```\n\n##### 异步组件和Suspense\n\n**注意： 这是一个实验性的特性，API可能随时修改**\n\nSuspense是一个内置的全局组件，该组件有两个插槽：\n\n- default： 如果default可以显示，那么显示default内容\n- fallback：如果default无法显示 那么会显示fallback插槽的内容\n\n##### $ref的使用\n\n###### 使用场景：\n\n在某些情况下，我们组件想要直接获取到元素对象或者子组件示例：我们可以给元素绑定一个ref的attribute属性\n\n###### 组件实例有一个$refs属性：\n\n它是一个对象，持有注册过ref attribute的所有DOM元素和组件实例\n\n##### 生命周期\n\n###### 定义：\n\n每个组件都会经历从创建，挂载，更新，卸载等一系列的过程。在这些过程的某个阶段，可能会想要添加一些属于自己的代码逻辑，（比如请求数据）这个时候就需要Vue给我们提供的生命周期函数来实现\n\n###### 使用：\n\n生命周期函数就是一些钩子函数，在某个时间会被Vue源码内部进行回调，我们调用生命周期函数在里面写自己的逻辑，这样就可以实现页面在加载完成同时做完我们的事情\n\n##### 组件的v-model\n\n```vue\n// 父组件\n<template>\n  <hy-input v-model=\"message\" v-model:title=\"title\"  @my-event=\"add\"></hy-input>\n</template>\n<script>\n  import HyInput from \'./HyInput.vue\';\n  export default {\n    components: {\n      HyInput\n    },\n    data() {\n      return {\n        message: \"Hello World\",\n      }\n    },\n    methods:{\n      add (val) {\n        this.num += val\n      }\n    }\n  }\n</script>\n// 子组件\n<template>\n  <input v-model=\"value\">\n  <input v-model=\"why\">\n</template>\n<script>\n  export default {\n    props: {\n      modelValue: String,\n      title: String \n    },\n    emits: [\"update:modelValue\", \"update:title\"],\n    computed: {\n      value: {\n        set(value) {\n          this.$emit(\"update:modelValue\", value);\n        },\n        get() {\n          return this.modelValue;\n        }\n      },\n      why: {\n        set(why) {\n          this.$emit(\"update:title\", why);\n        },\n        get() {\n          return this.title;\n        }\n      }\n    }\n  }\n</script>\n```\n\n###### 总结：\n\n父组件需要在使用的子组件中写`attribute``v-model`值为一个对象，当我们把这个值传入子组件后，子组件就可以通过`$emit`来实现在子组件中直接修改父组件中的值，并响应式更新\n\n具体实现是通过子组件的`computed`的`get`接收父组件传来的值和`set`修改父组件传来的值，使用`emits`来声明我们`this.$emit`所需要的第一个参数，通常是这样的`update:modelValue`\n\n##### 子组件绑定多个属性（使用v-model)\n\n###### 需求：\n\n我们希望在一个组件上使用多个`v-model`来绑定多个属性\n\n我们知道，默认情况下的`v-model`其实是绑定了`modelValue属性`和`@update:modelValue`事件，当我们需要给一个组件绑定多个属性时，可以这样写`v-model:num=\'data\'`其中num是传给子组件props接收参数的名称，data是传过去的父组件的data中定义的数据\n\n##### Mixin\n\n###### 产生背景：\n\n我们在实际开发中，会遇到组件和组件之间有时候会存在相同的代码逻辑，我们希望**对相同的代码逻辑进行抽取，这样就不用重复书写，**那么我们就可以使用Mixin来实现\n\n###### 使用：\n\nMixin提供了一种非常灵活的方式，来分发Vue组件中可复用功能，\n\n一个Mixin对象可以包含任何组件选项；\n\n当组件使用Mixin对象时，所有Mixin对象的选项将被混合进入该组件本身的选项中；\n\n###### Mixin的合并规则\n\n如果Mixin对象中的选项和组件对象中的选项发生冲突，vue会这样操作\n\n- 如果是data函数的返回值对象\n\n- - 返回值对象默认会进行合并\n  - 如果data返回值对象的属性发生了冲突，那么会保留组件自身的数据\n\n- 如果是生命周期钩子函数\n\n- - 钩子函数会被合并到数组中，都会被调用；\n\n- 值为对象的选项，例如methods，components, directives,将会合并为一个对象\n\n- - 例如methods选择，如果都定义了方法，那么就会合并，但是如果对象的key相同，那么就会取组件对象的键值对\n\n##### 全局混入Mixin\n\n如果组件中某些选择，是所有组件都需要的，那么我们可以使用全局Mixin\n\n- 全局Mixin可以使用应用app的方法mixin来完成注册\n- 一旦注册，那么全局混入的选项将会影响每一个组件', '2023-06-03 19:19:11', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (16, '最后一次系统的学习 React 状态管理库 Dva，', '##  React 状态管理 之 Dva\n\n​	最近在做需求的时候，需要使用到一个状态管理库来对多个组件共同状态进行统一管理，React 的状态管理库其实是有很多的，例如：最简单的 React Context ，到经典的 Redux，Mobx，再到 Hooks 时代的新起之秀：Recoil（我写的简介：https://www.code-nav.cn/post/1648709562175377409）还有很多优秀的库，可以看这篇：https://juejin.cn/post/7195513281228898363#heading-27\n\n接下来，我会按照下面思路写这篇文章：\n\n1. 什么时候需要使用状态管理库？\n2. 为什么选择状态管理库 Dva ？\n3. 什么是 Dva ？\n4. 怎么使用 Dva ？\n5. Dva 核心思想\n\n> 本文对一些分支知识点也进行记录，大家可以自行寻找需要阅读的地方\n\n### 一 ，什么时候需要使用状态管理库\n\n![image-20230517223030456](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/image-20230517223030456.png)\n\n​	因为 React 是 **单向数据流**（数据的流动方向总是从父组件向子组件），当我们想要**多个组件共享一个状态**的时候，我们就会发现我们需要一个存状态的地方，方便状态被多个组件读取，更新。这里介绍一下官方的解决方案 ，使用 **Context** 将它保存在更上层组件的组件中，使用 **Provider** 将值传递给下面的树，任何组件都可以读取它。这里它的缺点有以下几个：\n\n1. **组件的复用性降低：**如果一个组件依赖于某个 context，那么这个组件只能在这个 context 存在的地方使用。这可能会限制组件的复用性。\n2. **难以进行状态管理：**当需要管理的状态变得复杂时，只使用 Context 可能会变得困难。例如，如果需要管理一个全局状态，同时还需要进行异步操作，那么可能需要引入额外的库（如 Redux 或 MobX）。\n3. **性能问题：**当一个 Context 值改变时，所有消费这个 Context 的组件都将重新渲染，无论这个改变是否会影响到它们。如果有大量的组件订阅了同一个 Context，可能会引发性能问题。\n4. **代码结构问题：**过度使用 Context 可能会导致代码结构混乱。有时候很难确定哪个部分的代码应该放在 Context Provider 中，哪个部分的代码应该放在 Context Consumer 中。\n5. **不易于调试：**与 Redux 相比，Context API 的调试工具不够强大。如果状态传递链很长或者很复杂，问题定位和调试可能会比较困难。\n\n这些问题在面对复杂状态管理，异步状态更新的情况下，会变得极为棘手，于是社区就产生了很多优秀的状态管理库来解决问题\n\n​	我们还会在\n\n- **复杂的用户交互**：例如多个视图之间的跳转，多个组件之间的交互等，使用状态管理库（提取 UI 交互控制状态）可以帮助你更好地管理这些交互。\n- **大型项目：**对于大型的、复杂的项目，状态管理库可以帮助你更好地组织代码，使代码更易于理解和维护\n- **异步操作：**如果你的应用需要处理很多异步操作，例如网络请求，状态管理库可以帮助你更好地处理这些操作。\n- **跨组件通信：**如果你的组件树结构复杂，父子组件或者兄弟组件之间需要频繁通信，那么使用状态管理库可以简化这种跨组件的通信。\n\n**重点**：并不是所有的 React 项目都需要使用状态管理库。对于一些小型的、简单的项目，React 自带的状态管理（useState 和 useReducer hooks）可能已经足够了。引入过度复杂的状态管理库可能会导致代码变得更复杂，更难以理解和维护。引入复杂的状态管理库是为了解决\n\n1. 更加复杂的逻辑，\n2. 简化代码，\n3. 便于代码维护\n4. 提高代码可读性\n\n而不是为了让代码变得更糟糕\n\n### 为什么选择状态管理库 Dva ？\n\n​	我在开发的项目是基于 umi 3 搭建的，所以如果选择状态管理工具，那一定就是自带的` @umijs/plugin-dva ` 插件，如果我的项目是 next.js 搭建的，我应该会选择 Recoil ，因为它的代码更加简洁，方便阅读。\n\n​	不过，Dva也是一个很优秀的状态管理库，尤其是在大型项目中，它强制的规范了代码的书写方式，这样代码更加方便维护，因为规范代码在多人开发的大型项目是极为重要的，因为每个程序员都有自己的偏好代码书写方式，\n\n​	这里，还有一个问题，就是 umi 3 是有两个内置的状态管理插件的 ，分别是刚刚提到的`@umijs/plugin-dva` 和 更加轻量的`@umijs/plugin-model `。那如何选择呢？\n\n1. **@umijs/plugin-model：**这是 Umi 3 中的一个新特性，是一种基于 hooks 的轻量级全局状态管理方案。plugin-model 以文件为单位进行状态管理，对于每个 model 文件，内部会自动创建一个独立的 React context。并且在使用时，不需要 dispatch，直接使用 actions 即可。**最佳实践：**@umijs/plugin-model 更适合在项目中快速、轻量级地管理全局状态。它没有繁琐的概念，API 极简，适合小到中型项目。此外，它基于 React hooks，如果你的项目已经或者准备使用 React hooks，@umijs/plugin-model 会是一个不错的选择。\n2. **@umijs/plugin-dva：**这是将 DVA 集成到 Umi 3 中的插件，使用了 Redux、Redux-saga、React-router 等技术进行状态管理。DVA 是一种更完整的状态管理方案，包含了 action、reducer、effects 等概念。**最佳实践：**@umijs/plugin-dva 更适合在大型复杂项目中进行状态管理。它有完善的概念和方法，可以处理复杂的异步操作和副作用。如果你的项目中有复杂的状态管理需求，或者项目团队已经习惯了 Redux 的开发模式，那么 @umijs/plugin-dva 会是一个更好的选择。\n\n总的来说，`@umijs/plugin-model` 和 `@umijs/plugin-dva` 的主要区别在于其复杂度和应用场景。plugin-model 更简单、更轻量级，适合小到中型项目，它也更加自由，代码更加不可控，而 plugin-dva 更复杂、更强大，适合大型复杂项目，它的约束更多，代码更加规范。\n\n### 什么是 Dva ？\n\n​	我认为 Dva 最好的介绍文档，就是它的官网：https://dvajs.com/ ，它是由 蚂蚁 的前端大佬 sorrycc 写的，\n\n​	dva 首先是一个基于 [redux](https://github.com/reduxjs/redux) 和 [redux-saga](https://github.com/redux-saga/redux-saga) 的数据流方案，然后为了简化开发体验，dva 还额外内置了 [react-router](https://github.com/ReactTraining/react-router) 和 [fetch](https://github.com/github/fetch)，所以也可以理解为一个轻量级的应用框架\n\n​	我觉得Dva 产生的原因有 3 个，\n\n1. **简化 Redux 的使用**：Redux 是一个非常强大的状态管理工具，但是它的使用相对复杂，需要写很多模板代码。例如，你需要定义 actions，reducers，然后再将它们关联起来。DVA 对 Redux 进行了封装，让开发者可以更简单地使用 Redux。\n2. **处理异步操作**：Redux 本身并不支持异步操作，通常需要使用中间件如 Redux-thunk 或 Redux-saga 来处理。DVA 内置了 Redux-saga，使得处理异步操作变得更简单\n3. **集成路由**：在传统的 React + Redux 应用中，路由和状态管理通常是分开的。DVA 将 React-router 集成进来，使得路由和状态管理可以一体化处理。\n\n当然，它还提供了 插件系统，遵循 Elm 架构，\n\n**这里讲一下 Elm 架构**\n\nElm 架构是一种用于构建前端应用的架构模式，它起源于 Elm 语言，但已被许多其他的前端框架和库所采纳，包括 Redux 和 DVA。\n\nElm 架构主要包含以下几个部分：\n\n1. **Model**：模型代表了应用的状态。在一个计数器应用中，模型可能就是一个数字；在一个待办事项列表应用中，模型可能是一个代表待办事项的数组。\n2. **Update**：更新函数定义了如何根据接收到的 action 更新模型。它接收当前的模型和一个 action，然后返回一个新的模型。这个过程是纯函数，即同样的输入总会得到同样的输出，没有副作用。\n3. **View**：视图函数负责根据模型生成 UI。它接收模型作为参数，然后返回一些描述 UI 的代码（在 Web 开发中，通常是 HTML 或 JSX）。\n4. **Actions**：动作描述了用户或系统可能对应用做的操作。例如，在一个计数器应用中，可能有 \"增加\" 和 \"减少\" 两种操作。\n\n​    在 Elm 架构中，数据流是单向的：用户或系统通过触发动作来修改模型，然后更新函数根据动作和当前模型计算出新的模型，最后视图函数使用新的模型生成新的 UI。\n\n​	这种单向数据流使得应用的状态变化变得可预测和易于理解，也更便于调试和测试。因此，Elm 架构已经被广泛应用于前端开发中。\n\n### 怎么使用 Dva ？\n\n> 参考链接：https://dvajs.com/guide/getting-started.html\n\n​	我觉得最好学习 Dva 的方式就是自己写一个小 demo，例如：写一个需要状态共享，代码逻辑可以提取的小系统，先不使用任何状态管理库去实现，然后再用 Dva 实现，你会深刻体会到它的作用，它解决了什么问题。最好通过这个demo体验它的所有功能，然后再去看 Dva的概念，加深对状态管理库 Dva 思想的理解\n\n\n\n### Dva 核心思想\n\n>  参考链接：https://dvajs.com/guide/concepts.html\n\n![img](https://blog-1304565468.cos.ap-shanghai.myqcloud.com/blog/PPrerEAKbIoDZYr.png)\n\n​	在 DVA 中，所有的数据流都遵循同样的模式：首先，用户交互或者其他事件触发 action；然后，saga 中间件捕获这个 action，并可能触发异步操作，如数据请求；最后，根据 action 的类型，对应的 reducer 将会更新状态。\n\n​	DVA 还引入了 Model 的概念，将 Redux 中的 reducers、effects 和 subscriptions 集合在一起，使得相关的代码更加集中和模块化。通过这种方式，DVA 使得状态管理的逻辑更加清晰，更易于理解和维护。\n\n​	此外，DVA 还内置了路由管理功能，提供了基于路由的动态加载机制，使得大型应用的状态管理和路由管理可以统一处理。\n\n### 注意事项 & 经验\n\n1. **合理设计 Model**：在 DVA 中，Model 是核心的部分，对应的就是你的数据模型。一个好的 Model 设计应该是简单并且易于理解的，避免过度复杂的状态设计。\n2. **保持 Reducer 的纯净**：Reducer 是一个纯函数，它不应该产生任何副作用。在 Reducer 中，你不能直接修改传入的 state，而是应该返回一个新的 state，这样也符合React 的不变性，但是如果你觉得麻烦，可以通过\n3. **尽量减少 state 的复杂性**：尽量保持 state 的扁平化，避免过度的嵌套结构。这样可以使 state 更容易理解和操作。\n4. **善用 Effects**：Effects 是 DVA 中处理异步操作的地方。你可以在这里进行各种异步操作，如获取数据、延时操作等。\n5. **合理使用 Subscription**：Subscription 可以用来监听数据源并根据需要 dispatch action，但并不是所有的 action 都需要通过 Subscription 来触发。在某些情况下，直接在组件中 dispatch action 会更加方便和直观。\n6. **注意性能优化**：在编写代码时，你应该注意避免不必要的渲染和状态更新，以提高应用的性能。\n7. **遵循单一职责原则**：每个 Model 应该只负责管理一部分状态，每个 Component 应该只负责渲染一部分 UI。这样可以使你的代码更加模块化，更易于维护。\n8. **编写可测试的代码**：尽量让你的代码更容易进行单元测试。例如，你可以将业务逻辑尽可能抽取出来，使其不依赖于特定的组件或者环境。\n9. 直接在 model 中监听 state 的变化可能会导致逻辑混乱，不易于维护，因此并不推荐这样做。\n10. 在大多数情况下，你应该尽量在组件中监听 state 的变化，然后 dispatch action 来更新 state。\n11. 我们应该把 更新状态 state 和 同步操作 都在 Reducer 中实现，把异步事件，接口请求都在 Effect 中实现，\n12. 我们可以在 Subscription 中进行订阅数据源，数据源可以是\n\n- 当前的时间\n- 服务器的 websocket 连接\n- keyboard 输入\n- geolocation （用户的地理位置信息的变化）变化\n- history 路由变化等等。\n\n当数据源发生变化时，可以通过 dispatch 触发相应的 action，进而改变应用状态。\n\n', '2023-06-03 19:19:11', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (17, 'MySQL事务隔离级别详解', '# 一，简介\n在关系型数据库中，事务隔离级别是指多个并发事务之间的隔离程度\n\nMySQL 中事务的隔离级别一共分为四种，分别如下\n\n**READ-UNCOMMITTED**(读取未提交) ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。\n\n**READ-COMMITTED**(读取已提交) ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。\n\n**REPEATABLE-READ**(可重复读) ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。\n\n**SERIALIZABLE**(可串行化) ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。\n\n![image.png](https://pic.code-nav.cn/post_picture/1621702672539205634/NX4S8LNb-image.png)\n\n\n# 二，查看隔离级别\nMySQL8 之前使用如下命令查看 MySQL 隔离级别：\n\n//查看默认的全局隔离级别和当前 session 的隔离级别\n\n`SELECT @@GLOBAL.tx_isolation, @@tx_isolation;`\n\nMySQL8 开始，通过如下命令查看 MySQL 默认隔离级别：\n\n//就是关键字变了，由简写变成全写，其他都一样\n\n`SELECT @@GLOBAL.transaction_isolation, @@transaction_isolation;`\n\n更改当前隔离级别：\n\n`SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE]`\n\n# 三，SERIALIZABLE(可串行化):\n在SERIALIZABLE隔离级别下，事务将被视为**完全串行化**，因此每个事务都必须按顺序执行，就像是一个接一个地运行一样。这意味着每个事务都可以看到其他已经提交的事务所做的更改，但不会看到其他正在进行的或未提交的事务所做的更改。\n\nSERIALIZABLE隔离级别可以防止一些常见的并发问题，如脏读、不可重复读和幻读。它确保在任何给定时间点**只有一个事务可以访问特定数据**，从而保证了数据的**一致性和正确性**。但是，这种隔离级别也会带来一些性能问题，因为它会导致更多的锁定和更严格的并发控制。因此，应该谨慎使用SERIALIZABLE隔离级别，并在必要时考虑使用较低级别的隔离级别。\n\n# 四，REPEATABLE-READ(可重复读) :\nREPEATABLE-READ是一种常见的事务隔离级别，它比READ COMMITTED隔离级别提供了更高的隔离程度，但不如SERIALIZABLE隔离级别严格。\n\n在REPEATABLE-READ隔离级别下，事务在读取数据时会**锁定所涉及的所有数据**，以确保其他事务无法修改它们。这样可以防止脏读和不可重复读，因为其他事务无法在当前事务读取数据的同时修改它们。但是，REPEATABLE-READ隔离级别无法防止幻读，因为其他事务仍然可以插入新数据或删除现有数据。\n\n与READ COMMITTED隔离级别不同，REPEATABLE-READ隔离级别保证在同一事务中重复读取相同数据将会得到相同的结果。也就是说，在同一事务中，任何查询都将看到第一次查询时的相同数据快照，即使其他事务已经对这些数据进行了修改或删除。这种重复读的能力在某些应用程序中是非常重要的，因此REPEATABLE-READ是一种非常流行的事务隔离级别。\n\n需要注意的是，REPEATABLE-READ隔离级别也会带来一些性能问题，因为它会导致更多的锁定和更严格的并发控制。因此，应该根据应用程序的需求和性能要求来选择最适合的事务隔离级别。\n\n# 五，READ-COMMITTED(读取已提交) ：\nREAD-COMMITTED是一种常见的事务隔离级别，它提供了比READ-UNCOMMITTED更高的隔离程度。在READ-COMMITTED隔离级别下，事务在读取数据时**只会锁定正在被其他事务修改的数据**，而不是锁定所有涉及的数据。\n\n这样可以避免脏读，因为其他事务无法在当前事务读取数据的同时修改它们。但是，在READ-COMMITTED隔离级别下，其他事务可以在当前事务读取数据的同时提交修改，导致不可重复读，即同一个事务中的两次查询得到的结果不一致。\n\n需要注意的是，READ-COMMITTED隔离级别不会防止幻读，因为其他事务仍然可以插入新数据或删除现有数据。因此，如果幻读是一个问题，则应考虑使用更高级别的事务隔离级别，如REPEATABLE-READ或SERIALIZABLE。\n\nREAD-COMMITTED隔离级别是一种比较常见的隔离级别，可以在绝大多数应用场景中使用。但是，需要注意的是，它仍然会带来一些性能问题，因为它会导致更多的锁定和并发控制。因此，在选择事务隔离级别时，需要权衡数据的一致性和性能要求。\n\n# 六，READ-UNCOMMITTED(读取未提交) ：\nREAD-UNCOMMITTED是一种最低级别的事务隔离级别，也是最不严格的一种隔离级别。在READ-UNCOMMITTED隔离级别下，**事务可以读取其他事务尚未提交的数据**，即脏读（dirty read）。\n\n这种隔离级别的优点是可以提高并发性能，因为它不会在读取数据时对它们进行任何锁定或并发控制。但是，这种隔离级别的缺点是可能会导致数据的不一致性，因为读取的数据可能包含未提交或已回滚的更改，因此不建议在生产环境中使用。\n\n需要注意的是，大多数关系型数据库默认的事务隔离级别是READ-COMMITTED，而非READ-UNCOMMITTED。因此，如果需要使用READ-UNCOMMITTED隔离级别，通常需要显式地将隔离级别设置为该级别。\n\n总之，READ-UNCOMMITTED是一种非常不严格的事务隔离级别，应该谨慎使用，并且只在某些特定情况下考虑使用，例如对于只读取数据的报表查询等场景。\n\n# 七，如何理解四种隔离级别与脏读，幻读，不可重复读的关系\n笔者为何在这里才提到脏读，幻读，不可重复读，是因为我认为这些问题其实与不同隔离级别的特性密不可分，如果抛弃原理谈问题，其实理解是比较晦涩的，在关系型数据库中，事务隔离级别是指多个并发事务之间的隔离程度\n\n我先简单介绍一下并发事务存在的三种问题，这些问题都是因为**并发**访问数据库而导致的，因此在设计数据库应用程序时需要考虑并发控制和事务隔离，以确保数据的一致性和可靠性。关系型数据库通过提供不同的事务隔离级别来解决这些问题。不同的隔离级别提供了不同的并发控制机制，从而能够在数据的一致性和并发性之间进行权衡。\n\n## 脏读\n脏读（Dirty Read）是指一个事务读取了另一个事务尚未提交的数据。在这种情况下，如果另一个事务回滚，则第一个事务读取到的数据实际上是无效的或错误的。脏读通常会导致数据不一致，因此需要通过事务隔离来防止。\n\n## 不可重复读\n不可重复读（Non-repeatable Read）是指一个事务在读取某个数据行时，另一个事务修改了该数据行，导致第一个事务两次读取的结果不一致。不可重复读通常发生在一个事务多次读取同一数据时，而其他事务同时修改了该数据。因此，需要通过事务隔离来防止。\n\n## 幻读\n幻读（Phantom Read）是指一个事务在两次执行同一查询时，第二次查询发现了第一次查询没有发现的新数据行或者第一次查询发现了一些数据行，但是在事务提交前这些数据行被另一个事务删除了。这种现象通常发生在多行数据的插入、更新和删除操作中，它会导致数据不一致，因此需要通过事务隔离来防止。\n\n## 浅谈隔离级别的特性所产生的问题\n在READ-UNCOMMITTED隔离级别下，事务可以读取其他事务尚未提交的数据，所以会产生脏读问题，这是因为READ-UNCOMMITTED的特性导致的，当然也会存在不可重复读和幻读。\n\n在READ-COMMITTED隔离级别下，事务在读取数据时只会锁定正在被其他事务修改的数据，而不是锁定所有涉及的数据。这样可以避免脏读，因为其他事务无法在当前事务读取数据的同时修改它们，但是因为可以读到其他事务提交的数据，所以在其他事务提交前后，分别读，就会产生不可重复读的问题。\n\n在REPEATABLE-READ隔离级别下，会保证在同一事务中重复读取相同数据将会得到相同的结果。也就是说，在同一事务中，任何查询都将看到第一次查询时的相同数据快照，即使其他事务已经对这些数据进行了修改。以插入数据（数据比如叫做小尹）举例，这就会导致，虽然你在A事务查询的时候，数据库中没有小尹的数据，但是B事务此时修改了小尹的数据并且提交，此时A事务哪怕查询不到小尹的数据，但是插入时，依然会报错。这就是幻读。\n\n在SERIALIZABLE隔离级别下，事务将被视为完全串行化，因此每个事务都必须按顺序执行，就像是一个接一个地运行一样，自然并发条件下的问题就不会出现。', '2023-06-03 19:19:11', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (18, 'GitHub copilot chat 体验', '## GitHub copilot chat 体验\n\n​	最近，看到很多大佬分享 GitHub copilot chat ，据说能够让效率翻倍，抱着不相信，打假的心态我也弄一个，体验一下，结果真的很赞，下面分享使用 GitHub copilot chat 的过程\n\n​	首先，我们需要先了解一下 GitHub copilot chat 是一个什么东西，GitHub Copilot 是一个AI驱动的代码完成工具，由 OpenAI 和 GitHub 联合开发。它利用机器学习模型预测和生成代码，帮助开发者快速编写代码。而GitHub Copilot Chat 则是 GitHub Copilot 的扩展，它将 AI 编程助手融入到对话中，帮助解答编程问题，提供代码示例，甚至可以对代码进行审查和修正。这两种工具都是开发者的有效助手，帮助提升编程效率和代码质量。下面，我们需要做这几件事情👇🏻👇🏻\n\n1. 你必须购买了 GitHub copilot ，因为 chat 是基于它的，这个大家可以和我一样去某宝搜索，很便宜（一杯奶茶），我相信这绝对是你2023最具性价比的投资\n2. 当你购买成功后，就可以去 VSCode 左下角登录一下你购买服务的账号，然后在插件下载中心下载 GitHub copilot ，体验一下 GitHub copilot 的能力（我的代码产出 = chatGPT + GitHub Copilot），\n\n![image-20230527153837751](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20230527153837751.png)\n\n3. 申请加入 waitlist ：https://github.com/github-copilot/chat_waitlist_signup/join 当你加入 list 后，你再次进入这个网址你可以看到 👇🏻  还有，关注你留的邮箱，通过后会通过邮箱提醒你（很快，最多两个工作日）\n\n![image-20230527154016617](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20230527154016617.png)\n\n4. 下载我们的 VSCode insiders，因为只有在这里才能体验（坑了我好多时间）：https://code.visualstudio.com/insiders/\n\n![image-20230527154108314](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20230527154108314.png)\n\n5. 在我们刚刚下载的VSCode insiders中 下载一个插件GitHub Copilot Nightly：https://marketplace.visualstudio.com/items?itemName=GitHub.copilot-nightly 你会看到 👇🏻\n\n<img src=\"https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20230527154215438.png\" alt=\"image-20230527154215438\" style=\"zoom:50%;\" />\n\n​	如果没有看到，不要慌，先看下自己编辑器是否登录上了 GitHub ，看下右下角的弹窗是不是有一个 GitHub copilot chat 的提示让你登录 GitHub，如果这两个都完成了，重启一下，应该就能看到我们心心念念的 chat页面了\n\n### 体验 AI 的强大\n\n先看下，官方对它的定位，是这样描述的：我是你的副驾驶，我是来帮你更快完成任务的。我可以识别问题，解释甚至改进代码。您可以问一些一般性的问题，但我真正擅长的是帮助您编写代码。例如:\n\n- 为我的代码生成单元测试\n- 解释选定的代码\n- 建议，修复我代码中的错误\n\n\n​	如果你想了解更多关于我的能力和局限性，请查看副驾驶文档：https://docs.github.com/en/early-access/copilot/github-copilot-chat-transparency-note。最后它还鸡贼的进行了甩锅，我是由人工智能驱动的，所以意外和错误是可能的。不过也给我们程序员一点面子，要是不出错，那程序员不是要消失了是吧，我们一个一个功能来体验\n\n#### 为我的代码生成单元测试\n\n我先选中左侧我的函数，然后使用 `command + i` （windows 是`ctrl + i`）\n\n![image-20230527163056394](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20230527163056394.png)\n\n这里我的 prompt 是` /test Generate tests for  the selectd code with Mocha` 这里有两个注意事项，\n\n1. 我使用了 GitHub copilot chat 提供的 `/test` 关键字，用于生成单元测试代码\n2. 我在末尾添加了 生成的测试代码使用的框架 `Mocha`\n\n我们可以看到右侧就为我们生成了对应的单元测试代码，这里我们没有安装对应的单元测试库，所以就报错了，兄弟们，帮我看看它写的对不对？（我觉得应该是靠谱的）\n\n#### 解释选定的代码\n\n> 逐步解释选中代码的原理\n\n我依然使用 `command + i` 然后 prompt 就是它提供的 `/explain`\n\n![image-20230527163742419](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20230527163742419.png)\n\n#### 建议，修复我代码中的错误\n\n错误代码：![image-20230527164206558](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20230527164206558.png)\n\n这里，如果执行的话，会发现它并没有检测出来 hooks 写法的错误，这也很好理解，因为它不知道这段代码的上下文，我这样写 prompt 后，就好了\n\n![image-20230527164355663](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/snailrun/image-20230527164355663.png)\n\n### 其他功能\n\n1. `/ ext` ：询问`VS Code`扩展开发。\n2. `/fix：`修复针对所选代码中的问题提出修复建议。\n3. `/help ：`帮助关于 GitHub Copilot 的一般帮助\n4. `/vscode：`关于  VSCode 的问题\n5. `/clear：`清空当前会话\n\n### 使用体验总结\n\n1. 在左侧聊天的时候，它真的太懂程序员的懒了，它会自动预测下一个问题？这真的很智能\n2. 它最大的好处就是和编辑器完美融合，使用体验非常 nice，以后再也不用切换了\n3. 当我们在读一些源码的时候，我觉得 `/explain`真的太强大了吧，以后再也不怕看源码了\n4. 把它放在编辑器中，不代表它不能做其他事情，你完全可以把它当做一个chatGPT 3.5来用，嗯？？那以后上班玩 chatGPT 再也不怕被发现了，\n5. 当我们写完代码后，如果有很复杂的业务逻辑，很可能有一些没有测试出的 bug，我们可以直接选中代码去询问：“这段代码有什么改进的地方吗？”，“这段代码需要重构吗？”\n6. 我现在，当我们把我们的工作流程化了，我们完全可以使用 AI 来帮我们完成任务，例如：我们最常写的crud，如果代码够通用，我们写新的 crud 是不是就完全可以交给 AI，不像我们自己写，还有可能 复制粘贴错误\n7. 我们还可以问它我们在实现一些之前没有实现过的场景，怎么做，让我们写出更加健壮，可读性强的代码，因为我觉得它在学习了 GitHub 上那么多优秀的开源库后，它提供的基本上都是最佳实践，我们只需要写出更好的 prompt 即可\n\n​	最后，我还发现了一个宝藏，那就是 `GitHub Copilot Voice ` ：,我已经加入waitlist，以后写代码，可能都不需要键盘了，这真的泰裤辣！', '2023-06-03 19:19:11', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (19, '2月20日，面试题挑战', '我讲采用先答题（只求第一反应不求正确全面），之后再补充的形式答题。\n### 题目\n2月20日，面试题挑战  \n* 【Java】 \n1. JDK 和 JRE 和 JVM 分别是什么，有什么区别？  \n  需要区分这三者，只需知道他们的全称是什么即可。JDK即java development kit，顾名思义，即java开发工具包，它包含了jre和一些java开发工具和类库，例如java，javac，javadoc等。JRE即java runtime environment，也就是java运行时环境，它包含了jvm和一些核心类库。JVM即java virtual machine，也就是java虚拟机。\n2. 什么是字节码？采用字节码的最大好处是什么？  \n  字节码就是.java源文件通过javac编译之后的.class文件，之后用于jvm执行。最大好处待补充。\n4. 什么是数据库事务？讲一下事务的 ACID 特性？  \n数据库事务就是数据库的操作序列，即多个数据库的操作组合成的序列，要么都执行，要么都不执行。acid表示数据库管理系统中事务应具有的四个特效，原子性atomicity，连续性consistency，隔离性，持久性duration。待展开。\n* 【前端】  \n1. 有哪些常用的 HTML 标签？  \np,a,div,img,button,input等。\n3. CSS 选择器有哪些？优先级分别是什么？  \nid选择器#类型选择器.元素选择器p{}属性选择器eml[attr]后代选择器。优先级待补充。\n5. 有哪些常见的 CSS 布局？  \n盒子模型，以及display属性区分的内联元素，块级元素。其他待补充。\n\n', '2023-06-03 19:19:11', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (20, '彻底理解双指针算法', '\n\n# 学习目标\n\n1.  了解双指针算法是什么以及分类\n2.  理解双指针算法的原理\n3.  会用代码编写双指针算法\n4.  在实际题目中灵活运用双指针\n\n> 📌在数组的开章中我们提到了这个算法，如果没有看的话可以学完这一节再回头去看那一篇文章会恍然大悟！！\n\n# 什么是双指针？\n\n用最通俗的语言来讲所谓双指针算法是针对于遍历的过程的，我们平常在用for循环遍历的时候都是用单个指针在进行循环访问，而双指针就是用两个相同方向的或者相反方向的指针进行扫描，从而达道算法的目的。比如在一层循环里同时设置 i,j两个变量。\n\n换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算，将时间复杂度从log(n^2)降到log(n)。\n\n注意：这里的指针，并非专指C语言中指针的概念，而是指索引，游标或指针，可迭代对象等！\n\n# 双指针的分类\n\n1.  若两个指针指向同一数组，遍历**方向相同且不会相交**，则称为滑动窗口，用于解决**区间搜索**问题。\n2.  若两个指针指向同一数组，遍历**方向相反**，则可以用来搜索有序数组（需要提前**进行排序**）。\n3.  还有快慢指针，可以用来判断链表环路问题。 \n\n# 核心思想\n有重复计算的区间，用双指针优化。将上一个状态指针所表达的信息传递至下一状态，减少无谓的搜索。\n\n\n# 模板写法\n\n```cpp\nfor (int i = 0, j = 0; i < n; i ++ )\n{\n    while (j < i && check(i, j)) j ++ ;\n\n    // 具体问题的逻辑   \n   // 这是i,j分别两端的写法\n\n}\n\n//这是i,j分别两端的写法\nfor(int i=0,j=n-1;i<j;i++){\n    while(check()) j--;\n}\n\n```\n\n常见问题分类：\n\n(1) 对于一个序列，用两个指针维护一段区间\n\n(2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作\n\n常用于解决：数组、区间、字符串等问题\n\n# 经典例题\n\n## 移除元素\n\n给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。\n\n不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。\n\n元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。\n\n说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?\n\n请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。\n\n你可以想象内部操作如下:\n\n```cpp\n// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝\nint len = removeElement(nums, val);\n\n// 在函数里修改输入数组对于调用者是可见的。\n// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。\nfor (int i = 0; i < len; i++) {\n    print(nums[i]);\n}\n \n```\n\n示例 1：\n\n```cpp\n输入：nums = [3,2,2,3], val = 3\n输出：2, nums = [2,2]\n```\n\n解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = \\[2,2,3,3] 或 nums = \\[2,2,0,0]，也会被视作正确答案。\n示例 2：\n\n```cpp\n输入：nums = [0,1,2,2,3,0,4,2], val = 2\n输出：5, nums = [0,1,4,0,3]\n```\n\n解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。\n\n提示：\n\n0 <= nums.length <= 100\n0 <= nums\\[i] <= 50\n0 <= val <= 100\n\n## 双指针法\n\n### 分析题意\n\n首先来分析一下这道题为什么可以使用双指针法，很明显这是一道**考察数组**的题，我们上面说了数组的题可以考虑用双指针的解法，那么还有其他原因吗？双指针可以代替本来暴力写法的两层循环（不知道暴力学法怎么写的可以参考数组开章的那篇博客），从而**减小时间复杂度**，答案优化算法的目的。\n\n> 📌*当然我们必须先思考出暴力写法应该如何写，才能想到双指针的优化*。\n\n### 具体代码\n\n双指针法（快慢指针法）： **通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。**\n\n定义快慢指针\n\n-   快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组\n-   慢指针：指向更新 新数组下标的位置\n\n```cpp\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        int slow=0;//双指针  慢指针为长度\n        for(int fast=0;fast<nums.size();fast++){\n            if(nums[fast]!=val){\n                nums[slow]=nums[fast];\n                slow++;\n            }\n        }\n        return slow;//返回新的数组的下标 \n    }\n};\n```\n\n## 最长连续不重复子序列\n\n给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。\n\n#### 输入格式\n\n第一行包含整数 n。\n\n第二行包含 n 个整数（均在 0∼10^5范围内），表示整数序列。\n\n#### 输出格式\n\n共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。\n\n#### 数据范围\n\n$$\n1 \\leq n \\leq 10^{5}\n$$\n\n#### 输入样例：\n\n5\n\n1 2 2 3 5\n\n#### 输出样例：\n\n3\n\n### 核心思路\n\n本题使用i，j两个指针来维护一个区间，如果区间内没有重复的数字就让i指针一直向前移动并且用s\\[]数组来记录a\\[]数组中每个元素出现的次数，每出现一个重复的数字的时候就移动j和i重合，重新开始计算区间的长度，最后去更新一个最大的区间长度。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=100010;\nint a[N],s[N];\nint n;\n//双指针：找i和j存在什么规律：单调性\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n        \n    }\n    int res=1;\n    for(int i=1,j=1;i<=n;i++)\n    {\n        s[a[i]]++;//注意这一步的位置，向右扩展右端点\n         //当扩展完区间右端点之后，有可能这个元素q[i]会有重复，下面这个while循环就是用来去除重复\n        //去重只有一个办法，就是收缩区间左端点，同时收缩时要保证j是小于i的\n        while(j<i&&s[a[i]]>1)//如果执行这个循环，结束后i与j重合\n        {\n            \n            s[a[j]]--;\n            j++;\n        } \n        \n        res=max(res,i-j+1);\n        \n    }\n    cout<<res<<endl;\n    return 0;\n}\n```\n\n## 数组元素的目标和\n\n给定两个升序排序的有序数组 A 和 B，以及一个目标值 x。\n\n数组下标从 0 开始。\n\n请你求出满足 A\\[i]+B\\[j]=x的数对 (i,j)。\n\n数据保证有唯一解。\n\n#### 输入格式\n\n第一行包含三个整数 n,m,x，分别表示 A 的长度，B 的长度以及目标值 x。\n\n第二行包含 n个整数，表示数组 A。\n\n第三行包含 m 个整数，表示数组 B。\n\n#### 输出格式\n\n共一行，包含两个整数 i和 j。\n\n#### 数据范围\n\n数组长度不超过 10^5 &#x20;\n同一数组内元素各不相同。 &#x20;\n1≤数组元素≤10^9\n\n#### 输入样例：\n\n4 5 6\n\n1 2 4 7\n\n3 4 6 8 9\n\n#### 输出样例：\n\n1 1\n\n### 核心思路\n\ni从 0开始 从前往后遍历\nj从 m - 1开始 从后向前遍历\n\n> 📌和纯暴力的O(n2)算法的区别就在于：j指针不会回退\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/f4fc6cf94d1b48ecaa2fc60c87fe9a1f.png#pic_center)\n\n\n```cpp\n#include <iostream>\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\n\nint n, m, x;\nint a[N], b[N];\n\nint main()\n{\n    scanf(\"%d%d%d\", &n, &m, &x);\n    for (int i = 0; i < n; i ++ ) scanf(\"%d\", &a[i]);\n    for (int i = 0; i < m; i ++ ) scanf(\"%d\", &b[i]);\n    //设置前后两个指针  去更新j指针\n    for (int i = 0, j = m - 1; i < n; i ++ )\n    {\n        while (j >= 0 && a[i] + b[j] > x) j -- ;\n        if (j >= 0 && a[i] + b[j] == x) cout << i << \' \' << j << endl;\n    }\n\n    return 0;\n}\n\n\n```\n\n# 总结一下\n\n本篇我们学习了双指针算法，可以回头看一下学习目标大家有没有达成了呢\\~\n\n从例题中可以看到这些题都有一个共性就是都提到了数组这一概念，也就是上一篇数组博客\n\n的内容理解透彻以后再来看这一篇会更加清晰一些😀\n\n创作不易，喜欢的话动动小手点个免费的赞也申请加精啦，谢谢大家！！\\~😀💜❤️\n\n', '2023-06-03 19:19:11', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (21, '极简Next.js指南，做一个自己的Next.js项目', '## Next.js 学习\n\n\n\n官方文档地址：https://nextjs.org/\n\n\n\n**要有效地使用 Next.js，熟悉 JavaScript、React 和相关的 Web 开发概念是前提**\n\n\n\n### 1. 相关技术\n\n\n\n1. unpkg：https://unpkg.com/ \n\n1. 1. 一个快速的全球内容交付网络，适用于 npm 上的所有内容。使用它可以使用如下 URL 快速轻松地从任何包中加载任何文件：`unpkg.com/:package@:version/:file`\n   2. 一个CDN服务\n\n1. \n\n\n\n### 1. 快速创建一个Next.js应用\n\n\n\n#### 开发环境\n\n\n\n1. 安装Node.js环境到你的电脑 ；Node.js > 14.6.0 或者最近稳定版本（推荐使用[nvm](https://www.runoob.com/w3cnote/nvm-manager-node-versions.html)管理node版本）\n2. 一台生产力电脑\n3. 一个自己熟悉的编辑器，这里推荐`VSCode`或者`WebStorm`\n4. 跟着[官方教程](https://nextjs.org/docs/getting-started)， \n\n1. 1. init code：`pnpm create next-app`,有选择，选择你需要的能力即可\n   2. `npm run dev` 启动项目\n   3. \n\n\n\n### 2. Next.js如何工作\n\n\n\nNext.js 被一些世界上最大的公司使用，它使您能够通过扩展最新的 React 功能并集成强大的基于 Rust 的 JavaScript 工具来创建全栈 Web 应用程序以实现最快的构建。\n\n\n\n#### 1. 从开发环境到生产环境\n\n\n\n讲了，开发环境和生产环境的区别，Next.js对此做的优化\n\n\n\n##### 开发环境和生产环境区别\n\n\n\n- 在开发期间，您正在本地计算机上构建和运行应用程序。\n- 投入生产是让您的应用程序准备好部署和供用户使用的过程。\n\n\n\n##### Next.js针对其进行的优化\n\n\n\n- Next.js 会针对开发人员及其构建应用程序的经验进行优化。它具有旨在改善开发人员体验的功能，例如 **TypeScript** 和 **ESLint** 集成、**快速刷新**等。\n- 在生产阶段，Next.js 会针对最终用户以及他们使用该应用程序的体验进行优化。它旨在转换代码以使其具有*高性能*和*可访问性*。 由于每个环境都有不同的考虑因素和目标，因此将应用程序从开发转移到生产需要做很多事情。例如，应用程序代码需要**编译**、**捆绑**、**缩小**和**代码拆分**。\n\n\n\n##### Next.js真的可以让你的应用更加优秀\n\n\n\n因为 Next.js 有一个用 Rust 编写的编译器，一种低级编程语言，以及 SWC，一个可用于编译、缩小、捆绑等的平台。\n\n\n\n**接下来，我们具体看下Next.js为我们做了什么吧！**\n\n\n\n#### 2. 编译\n\n\n\n将我们写的代码，通过Next.js的魔法转化游览器能够解析的JavaScript代码，\n\n\n\n\n![compiler.png](https://pic.code-nav.cn/post_picture/1619930914211520514/vYaPRwe8-compiler.png)\n\n\n\n我们编写对开发人员更友好的语言编写代码，例如 JSX、TypeScript 和现代版本的 JavaScript。虽然这些语言提高了开发人员的效率和信心，但游览器却并不知道这是什么，我们需要将其编译为游览器理解的代码，\n\n\n\n##### 编译发生时机\n\n\n\n编译发生在您编辑代码的开发阶段，并且作为构建步骤的一部分，为您的应用程序做好生产准备。💎💎\n\n\n\n**编译是指获取一种语言的代码并将其输出为另一种语言或该语言的另一个版本的过程。**\n\n\n\n#### 3. 压缩\n\n\n\n我们项目源码可能包含代码运行所不需要的额外信息，例如注释、空格、缩进和多行（为了给开发者看）。生产环境打包好的代码是不需要的，因为它是给游览器理解，所有我们打包的时候需要移除这些额外信息\n\n\n\n\n![minifier.png](https://pic.code-nav.cn/post_picture/1619930914211520514/fKVomBMm-minifier.png)\n\n\n\n##### Next.js的压缩\n\n\n\n在 Next.js 中，JavaScript 和 CSS 文件会自动缩小以用于生产。💎💎\n\n\n\n**缩小是在不更改代码功能的情况下删除不必要的代码格式和注释的过程。目标是通过减小文件大小来提高应用程序的性能。**\n\n\n\n#### 4. 捆绑\n\n\n\n开发者通过拆解一个应用为：模块，组件，函数，方法，类，第三方库等等；通过导入导出实现功能，这同时创建了一个复杂的文件依赖关系网\n\n\n\n\n![bundler.png](https://pic.code-nav.cn/post_picture/1619930914211520514/N4fPI4Ck-bundler.png)\n\n\n\n为了减少用户访问网页时对文件的请求数量（请求文件数减少，页面加载就更快）。捆绑是解决网络依赖关系并将文件（或模块）合并（或“打包”）为浏览器优化捆绑包的过程\n\n\n\n**编译是将代码转换成浏览器可以解析的东西。捆绑正在解决您的应用程序依赖关系图并减少文件数量。**\n\n\n\n#### 5. 代码拆分\n\n\n\n代码拆分是将应用程序的包拆分为每个入口点所需的较小块的过程。目标是通过仅加载运行该页面所需的代码来缩短应用程序的初始加载时间。\n\n\n\n\n![cpdeSplittinng.png](https://pic.code-nav.cn/post_picture/1619930914211520514/2qqxKHVI-cpdeSplittinng.png)\n\n\n\n开发人员通常将他们的应用程序分成多个页面，可以从不同的 URL 访问这些页面。这些页面中的每一个都成为应用程序的唯一入口点。\n\n\n\nNext.js 内置了对代码拆分的支持。在构建步骤中，您的 pages/ 目录中的每个文件都将自动代码拆分为自己的 JavaScript 包。\n\n\n\n未来：\n\n\n\n- 页面之间共享的任何代码也被拆分到另一个包中，以避免在进一步导航时重新下载相同的代码。\n- 初始页面加载后，Next.js 可以开始预加载用户可能导航到的其他页面的代码。\n- **动态导入**是另一种手动拆分最初加载代码的方法。\n\n\n\n#### 6. 构建时和运行时\n\n\n\n两个非常重要的概念，帮助理解Next.js的底层工作原理\n\n\n\n**构建时间（或构建步骤）**是为生产应用程序代码准备的一系列步骤的名称。 当您构建应用程序时，Next.js 会将您的代码转换为生产优化文件，以准备部署到服务器并供用户使用。这些文件包括：\n\n\n\n- 静态生成页面的 HTML 文件\n- 用于在服务器上呈现页面的 JavaScript 代码\n- 使页面在客户端交互的 JavaScript 代码\n- CSS文件\n\n\n\n**运行时（或请求时间）**是指在构建和部署应用程序后，应用程序响应用户请求而运行的时间段。 接下来，让我们讨论一下本节中介绍的一些术语，例如客户端、服务器和渲染。\n\n\n\n#### 7. 客户端和服务端\n\n\n\n在 Web 应用程序的上下文中，\n\n\n\n-  客户端是指：用户设备上的浏览器，它向服务器发送应用程序代码请求。然后它将从服务器接收到的响应转换为用户可以与之交互的界面。 \n-  服务端：指数据中心的计算机，它存储您的应用程序代码，接收来自客户端的请求，进行一些计算，并发回适当的响应。 \n\n\n\n\n![clientServer.png](https://pic.code-nav.cn/post_picture/1619930914211520514/2WAwLrvf-clientServer.png)\n\n\n\n#### 7. 渲染\n\n\n\n将您在 React 中编写的代码转换为 UI 的 HTML 表示形式是不可避免的工作单元。这个过程称为渲染。\n\n\n\n渲染可以在服务器或客户端上进行。它可以在构建时提前发生，也可以在运行时针对每个请求发生。 使用 `Next.js`，可以使用三种类型的渲染方法：\n\n\n\n- 服务器端渲染\n- 静态站点生成\n- 客户端渲染\n\n\n\n##### 1. 预渲染\n\n\n\n**服务器端渲染**和**静态站点生成**也称为预渲染，因为 *外部数据的获取* 和  *React 组件到 HTML 的转换* 发生在结果发送到客户端之前。\n\n\n\n##### 2. 客户端渲染 VS预渲染\n\n\n\n在标准的 React 应用程序中，浏览器从服务器接收一个空的 `HTML shell` 以及构建 `UI 的 JavaScript 指令`。这称为客户端呈现，因为初始呈现工作发生在用户的设备上。\n\n\n\n\n![clientRender.png](https://pic.code-nav.cn/post_picture/1619930914211520514/Nq1rlBq1-clientRender.png)\n\n\n\n注意：您可以选择使用 React 的 useEffect() 或数据获取挂钩（如 useSWR）获取数据，从而为 Next.js 应用程序中的特定组件使用客户端呈现。\n\n\n\n相比之下，Next.js **默认预渲染每个页面**。预渲染意味着 HTML 是预先在服务器上生成的，而不是由用户设备上的 JavaScript 完成的。 实际上，这意味着对于完全由客户端呈现的应用程序，用户将在完成呈现工作时看到一个空白页面。与预渲染应用相比，用户将看到构建的 HTML，所以预渲染是对用户更加友好的渲染\n\n\n\n\n![preRender.png](https://pic.code-nav.cn/post_picture/1619930914211520514/B4muTLQx-preRender.png)\n\n\n\n接下来，具体看下两种预渲染：\n\n\n\n##### 3. 服务端渲染\n\n\n\n使用服务器端呈现，页面的 HTML 是在服务器上为每个请求生成的。然后将生成的 HTML、JSON 数据和使页面具有交互性的 JavaScript 指令发送到客户端。 在客户端，HTML 用于显示快速的非交互式页面，而 React 使用 JSON 数据和 JavaScript 指令使组件具有交互性（例如，将事件处理程序附加到按钮）。这个过程称为**水合作用**。 在 Next.js 中，您可以使用 `getServerSideProps` 选择服务器端呈现页面。\n\n\n\n注意：React 18 和 Next 12 引入了 React 服务端组件的 alpha 版本。服务器组件完全在服务器上呈现，不需要客户端 JavaScript 来呈现。此外，服务端组件允许开发人员在服务器上保留一些逻辑，并且只将该逻辑的结果发送给客户端。这减少了发送到客户端的包大小并提高了客户端渲染性能。了解有关 React 服务端的更多信息 组件在这里。\n\n\n\n##### 4. 静态站点生成\n\n\n\n使用静态站点生成，HTML 是在服务器上生成的。但与服务器端呈现不同的是，在运行时没有服务器。取而代之的是，在部署应用程序时，在构建时生成一次内容，HTML 存储在 CDN 中并为每个请求重新使用。 在Next.js 中，您可以选择使用 `getStaticProps` 静态生成页面。\n\n\n\n注意：您可以在构建网站后使用[增量静态重新生成来](https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration)创建或更新静态页面。这意味着如果您的数据发生变化，您不必重建整个站点。\n\n\n\nNext.js 的美妙之处在于，您可以逐页为您的用例选择最合适的呈现方法，无论是静态站点生成、服务器端呈现还是客户端呈现。要详细了解哪种渲染方法适合您的特定用例，请参阅数据获取文档。 在下一节中，我们将讨论您的代码在部署后可以存储或运行的位置。\n\n\n\n#### 8. 网络\n\n\n\n了解应用程序代码的存储位置和部署到网络后的运行位置很有帮助。您可以将网络视为能够共享资源的链接计算机（或服务器）。\n\n\n\n对于 Next.js 应用程序，您的应用程序代码可以分发到原始服务器、内容分发网络 (CDNs) 和边缘。让我们看看它们分别是什么：\n\n\n\n##### 1. 原始服务器\n\n\n\n正如我们之前讨论的，服务器是指存储和运行应用程序代码原始版本的主计算机。 我们使用术语源来区分此服务器与应用程序代码可以分发到的其他地方，例如 CDN 服务器和边缘服务器。 当源服务器收到请求时，它会在发送响应之前进行一些计算。该计算工作的结果可以移动到 CDN（内容分发网络）。\n\n\n\n##### 2. 内容分发网络\n\n\n\nCDN 在全球多个位置存储静态内容（如 HTML 和图像文件），并放置在客户端和源服务器之间。当有新请求进来时，距离用户最近的 CDN 位置可以使用缓存的结果进行响应。\n\n\n\n\n![cdnServer.png](https://pic.code-nav.cn/post_picture/1619930914211520514/Gi6ZbX3p-cdnServer.png)\n\n\n\n这减少了源端的负载，因为不必在每个请求上都进行计算。它还使用户更快，因为响应来自地理位置更接近他们的位置。 在 Next.js 中，由于可以提前完成预渲染，因此 CDN 非常适合存储工作的静态结果——使内容交付更快。\n\n\n\n##### 3. 边缘\n\n\n\n边缘是网络边缘（或边缘）的广义概念，最接近用户。 CDN 可以被视为“边缘”的一部分，因为它们将静态内容存储在网络的边缘（边缘）。 与 CDN 类似，边缘服务器分布在世界各地的多个位置。但与存储静态内容的 CDN 不同，一些边缘服务器可以运行一小段代码。 这意味着缓存和代码执行都可以在靠近用户的边缘完成。 通过将一些传统上在客户端或服务器端完成的工作转移到边缘，您可以使您的应用程序性能更高，因为它减少了发送到客户端的代码量，并且用户的部分请求不必全部执行返回原始服务器的方式 - 从而减少延迟。请在此处查看带有 Next.js 的 Edge 示例。 在 Next.js 中，您可以使用中间件在边缘运行代码，很快就会使用 React 服务器组件。\n\n\n\n## END\n\n\n\n恭喜你看到了这里，Next.js的基础课程已经结束，现在 我们应该知道Next.js可以帮我们快速创建一个基于react的应用程序，它能够帮我们更加出色的完成打包，构建，让我们的应用程序更加快速的响应给用户，可以争对开发环境和部署环境进行特殊设置', '2023-06-03 19:19:11', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (22, '整合SpringSecurity自定义登录流程', '### 前言\n\n自定义登录流程是整合 SpringSecurity 开发必不可少的一步。[上篇文章](https://juejin.cn/post/7227020874888331324)我们介绍了整合数据库的登录，本篇文章在此基础上整理了 SpringSecurity + JWT + Redis 的登录流程。\n\n### 整体流程图\n\n登录及认证的整体流程如下图：\n\n![1683127723301-5c233af9-3c04-4e44-bada-a805cb4d73aa.png](https://pic.code-nav.cn/post_picture/1626574509983178753/uL6iuM5N-1683127723301-5c233af9-3c04-4e44-bada-a805cb4d73aa.png)\n\n### 依赖\n\n除了 SpringSecurity 的相关依赖外，还需要 Redis 和 hutool （强大且全面的工具包，本篇文章中 JWT 的相关类也来自该包） 的依赖。\n\n```xml\n<!-- springboot整合的redis依赖，里面集成了 spring-data-redis -->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n<dependency>\n    <groupId>cn.hutool</groupId>\n    <artifactId>hutool-all</artifactId>\n    <version>5.8.13</version>\n</dependency>\n```\n\n### 配置\n\n在整个流程中，我们用到了 SpringSecurity + JWT + Redis ，需要配置的是SpringSecurity 和 Redis。\n\n##### SpringSecurity 配置\n\n```java\n@Configuration\npublic class SpringSecurityConfig extends WebSecurityConfigurerAdapter {\n\n    @Resource\n    private JwtFilter jwtFilter;\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n\n    /**\n     * 注入 AuthenticationManager 对象，用于调用认证方法\n     *\n     * @return\n     * @throws Exception\n     */\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception {\n        return super.authenticationManagerBean();\n    }\n\n    /**\n     * 放行登录接口\n     */\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http\n                // 关闭csrf\n                .csrf().disable()\n                // 不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                // 把jwt过滤器放到UsernamePasswordAuthenticationFilter前,便于先判断用户是否登录,再决定是否登录\n                .authorizeRequests()\n                // 对于登录接口允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n        http.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\n\n    }\n\n}\n\n```\n\n在配置类中，我们注入了 AuthenticationManager 对象。这个对象在上篇文章我们提到过，用于调用认证方法。但是在父类 WebSecurityConfigurerAdapter 中并没有将它注入到容器中，而我们又需要在自己的登录接口中调用它，因此需要重写 authenticationManagerBean 方法并将返回的对象注入到容器中。\nconfigure(HttpSecurity http) 方法用于配置路由，只开放登录接口，其他接口都需要认证。\n\n##### Redis配置\n\n```java\n@Configuration\npublic class RedisConfig {\n\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(LettuceConnectionFactory lettuceConnectionFactory) {\n        // 设置序列化\n        Jackson2JsonRedisSerializer<Object> jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<Object>(\n                Object.class);\n        ObjectMapper om = new ObjectMapper();\n        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n        om.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n        jackson2JsonRedisSerializer.setObjectMapper(om);\n        // 配置redisTemplate\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<String, Object>();\n        redisTemplate.setConnectionFactory(lettuceConnectionFactory);\n        RedisSerializer<?> stringSerializer = new StringRedisSerializer();\n        redisTemplate.setKeySerializer(stringSerializer);// key序列化\n        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);// value序列化\n        redisTemplate.setHashKeySerializer(stringSerializer);// Hash key序列化\n        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);// Hash value序列化\n        redisTemplate.afterPropertiesSet();\n        return redisTemplate;\n    }\n}\n\n\n```\n\n在 Redis 配置中大部分是常规的序列化配置，特殊的是 ObjectMapper ，这个配置是为因为存储在 Redis 的实体类中除了成员变量的 get 方法外，其他方法不能有返回值，否则会导致反序列化异常，而 ObjectMapper 就是为了解决这个问题。\n反序列化异常的问题可以通过下面的代码验证\n\n```java\n@Test\npublic void test(){\n    RedisTestEntity entity = new RedisTestEntity();\n    entity.setName(\"111\");\n    redisTemplate.opsForValue().set(\"name\", entity);\n}\n\n@Test\npublic void get(){\n    Object name = redisTemplate.opsForValue().get(\"name\");\n    System.out.println(name);\n}\n\n@Data\npublic class RedisTestEntity {\n    private String name;\n\n    public Integer requireAge(){\n        return 18;\n    }\n}\n```\n\n### 定义登录接口\n\n##### 参数的接收\n\n```java\n@Data\npublic class UserLogin {\n    private String username;\n    private String password;\n}\n```\n\n##### controller部分\n\n```java\n@PostMapping(\"/login\")\npublic R<String> login(@RequestBody UserLogin userLogin){\n    String jwt = securityService.login(userLogin);\n    return R.success().data(jwt);\n}\n```\n\ncontroller 只是负责匹配路由和返回数据，业务通过 service 的相关方法完成，因此 controller 中没有太多代码\n\n##### service部分\n\n```java\n@Resource\nprivate AuthenticationManager manager;\n@Resource\nprivate RedisTemplate redisTemplate;\n@Override\npublic String login(UserLogin userLogin) {\n    Authentication userAuthentication = new UsernamePasswordAuthenticationToken(userLogin.getUsername(), userLogin.getPassword());\n    Authentication authenticate = manager.authenticate(userAuthentication);\n    // 如果认证成功则进入生成token的逻辑\n    if (authenticate.isAuthenticated()) {\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\n        SysUser user = loginUser.getUser();\n        // 将登录成功的对象存入redis\n        redisTemplate.opsForValue().set(KeyUtil.getLoginUserKey(user.getUserId()), loginUser);\n        // 生成token\n        String token = JWT\n                .create()\n                .setPayload(userLoginId, user.getUserId())\n                // (签发时间)---------(生效时间)---------(当前时间)---------(失效时间)\n                .setIssuedAt(new Date())\n                // 过期时间七天\n                .setExpiresAt(new Date(System.currentTimeMillis() + DateUnit.WEEK.getMillis()))\n                // // 设置HS256为加密算法，以用户的密码为盐（密钥）\n                .setSigner(\"HMD5\", salt.getBytes(StandardCharsets.UTF_8))\n                .sign();\n\n        return token;\n    }\n    throw new RuntimeException(\"用户名或密码错误\");\n}\n```\n\nservice 完成了登录的主要流程，包括：\n\n1. 调用 AuthenticationManager 实例的 authenticate 方法对用户的账号密码进行验证，该方法会调用到我们上篇文章自定义的方法，通过查询数据库的数据完成校验\n2. 如果校验成功，则将用户信息存入 Redis 并生成相应 token ，同时将用户 id 存入 token 的荷载中，失败则抛出异常\n\n### 登录过滤器\n\n完成登录后，在以后的每次请求都需要在请求头中带上 token 以便于认证，认证操作通过过滤器完成（关于 jwt 的具体知识本篇文章不做探讨，不熟悉请自行查阅相关资料）。\n\n```java\n@Component\npublic class JwtFilter extends OncePerRequestFilter {\n\n    @Resource\n    private RedisTemplate redisTemplate;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {\n        String token = request.getHeader(\"token\");\n        // 没有token，去走登录流程\n        if (StrUtil.isBlank(token)) {\n            filterChain.doFilter(request, response);\n            return;\n        }\n        // token不能为空\n        JWT jwt = JWTUtil.parseToken(token);\n        // 验证token是否合法\n        HMacJWTSigner singer = new HMacJWTSigner(AlgorithmUtil.getAlgorithm(\"HMD5\"), salt.getBytes(StandardCharsets.UTF_8));\n        boolean common = jwt.verify(singer);\n        // 验证时间，失败会抛出异常\n        try {\n            JWTValidator.of(jwt).validateDate(DateUtil.date());\n        } catch (ValidateException exception) {\n            throw new TokenInvalidException(\"token异常\");\n        }\n        if (common){\n            NumberWithFormat userIdObj = (NumberWithFormat)jwt.getPayload(userLoginId);\n            Integer userId = userIdObj.intValue();\n            LoginUser loginUser = (LoginUser) redisTemplate.opsForValue().get(KeyUtil.getLoginUserKey(userId));\n            // 如果用户不存在，说明token异常\n            if (loginUser == null) {\n                throw new TokenInvalidException(\"token异常\");\n            }\n\n            // 将用户信息存入 SecurityContextHolder ，以便本次在请求中使用\n            UsernamePasswordAuthenticationToken authenticationLoginUser = new UsernamePasswordAuthenticationToken(loginUser, null, null);\n            SecurityContextHolder.getContext().setAuthentication(authenticationLoginUser);\n\n            filterChain.doFilter(request, response);\n        }\n\n    }\n}\n```\n\n我们自定义的过滤器类继承了 OncePerRequestFilter 类并重写了 doFilterInternal 方法，然后在 SpringSecurity 的配置类中将其添加到 UsernamePasswordAuthenticationFilter 前面（校验账号密码之前），对应配置类中的如下代码\n\n```java\nhttp.addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);\n```\n\n在过滤器中，我们首先校验了 token 是否存在。如果不存在则直接放行，然后在后续校验权限时会被自动拦截下来。存在则验证 token 的合法性，通过后从 token 拿到用户 id ，从 Redis 中获取到用户信息，如果不存在说明用户的登录状态异常（可能是退出了登录状态，后文会说）。从 Redis 中取到用户信息后，就可以将用户信息存到 SecurityContextHolder 中，方便后续进行认证、授权以及使用。最后放行，执行后续操作。\n\n### 退出登录\n\n在做完前面的操作后，退出登录的操作就很简单了。\n\n```java\n@PostMapping(\"/logout\")\npublic R<String> logout(){\n    Boolean delete = securityService.logout();\n    return R.success().data(delete);\n}\n```\n\n```java\n@Override\npublic Boolean logout() {\n    LoginUser loginUser = (LoginUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n    Integer userId = loginUser.getUser().getUserId();\n    Boolean delete = redisTemplate.delete(KeyUtil.getLoginUserKey(userId));\n    return delete;\n}\n```\n\ncontroller 和 service 的代码分别如图。\n在 service 中我们删除了 Redis 中的用户信息，这也就解释了为什么过滤器中会存在 token 合法但是用户信息不存在的情况（退出登录），当然也可能有其它的特殊情况。\n\n### 结语\n\n本篇文章就到这了，下一篇应该是关于授权的内容，我们下次再见。', '2023-06-03 19:19:11', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (23, '企业项目研发流程', '大家好，我是鱼皮。\n\n很多未工作过的小伙伴都很好奇：企业中做项目是怎样的流程？尤其是大厂那些百万用户的项目，和自己学编程时做项目到底有什么区别呢？\n\n**实话说，区别可大了！**\n\n自己开发项目那是单打独斗，自己掌握命运，不会拖垮队友；但企业中开发项目是开团打本，大家是一根绳上的蚂蚱，每个人都会影响整个项目。\n\n![](https://qiniuyun.code-nav.cn/image-20210712012036685.png)\n\n我自己也在几家公司实习过，不得不说，大厂和其他公司的研发流程也有很大的区别。\n\n因此，对于大多数同学，如果没有在大厂工作过，对很多研发环节可能都是一无所知的。\n\n所以今天给大家揭秘一下大厂的项目研发流程，帮大家开拓思路。\n\n正好之前有同志质疑我的日常工作就只有写代码和摸鱼？！这篇文章就作为回击，让他明白，在大厂做项目，可不止写代码那么简单！\n\n![](https://qiniuyun.code-nav.cn/image-20210712011545940.png)\n\n注意：这篇文章更侧重于理论知识，鱼皮曾经在星球直播带大家以实践的方式系统学习团队合作开发项目的方法，保证大家都能上线自己的项目，可以看下 [星球项目训练营](https://t.zsxq.com/0cg8VKgdC) 。如果还未加入星球，欢迎 [加入编程导航知识星球](https://yupi.icu/) 。\n\n本文视频版：https://www.bilibili.com/video/BV11q4y1T7kY\n\n\n\n## 大厂研发流程揭秘\n\n为了规范团队、保证项目的进展，大厂研发流程通常还是比较复杂的。\n\n可以分为很多个阶段，用一张思维导图来概括：\n\n![一线大厂研发流程导图](https://qiniuyun.code-nav.cn/%E4%B8%80%E7%BA%BF%E5%A4%A7%E5%8E%82%E7%A0%94%E5%8F%91%E6%B5%81%E7%A8%8B%E6%8F%AD%E7%A7%98.png)\n\n> 需要注意的是，以上阶段并不是完全按从上到下的顺序执行，阶段间可能存在交叉，比如 **技术选型** 其实在 **设计阶段** 就应该考虑。\n\n\n\n正式工作一年多，我也是经历过多次项目的完整研发流程的。下面就以我的视角，带大家快速过一遍~\n\n（为了内容更有趣，以下故事有虚构成分）\n\n\n\n### 需求阶段\n\n今天是周一，鱼皮像往常一样骑着他的小电动车来到公司，殊不知，等待他的是一场噩梦的开始。\n\n\n\n#### 需求产生\n\n上午十点，产品妹子找到鱼皮，告诉他：咱们的系统上线后，用户表示很多功能并不好用，需要大改。\n\n老板也找到鱼皮，告诉他：我今天打开页面竟然加载了十几秒，咱们这个系统的性能太烂了吧！\n\n鱼皮心想：呕豁，完蛋！估计得做个新的项目了，又要开会了。\n\n![](https://qiniuyun.code-nav.cn/image-20210712141645333.png)\n\n果然，没过多久，屏幕上弹出了一条 “欢迎加入会议” 的邀请。\n\n\n\n#### 需求评审\n\n第二天上午，老板、产品、测试、几位开发大哥和鱼皮一起来到会议室，具体讨论昨天提到的那些需求 **是否合理、要不要做** ？\n\n产品妹子打开文档，说到：这一期呢，我们要做这几个需求，下面我来详细讲一下，大家一起评估下有没有问题。\n\n\n\n#### 需求分析\n\n接下来，产品妹子正在对着屏幕侃侃而谈、疯狂输出时，旁边的开发大哥坐不住了。\n\n开发大哥：这个需求不合理啊！\n\n产品：为啥不合理？用户就是有这个需求啊！\n\n开发大哥：我知道，实现不了啊！\n\n于是开始了经典的产品开发撕逼大战。。。\n\n![](https://qiniuyun.code-nav.cn/image-20210712141444097.png)\n\n而鱼皮正躲在角落冷静分析 **这个需求怎么做** ，过了一会儿，提出了一种改动低、实现快的解决方案，平息了这场战争。\n\n\n\n#### 排期\n\n确定需求合理、可实现之后，产品妹子问到：那这个需求啥时候能上线呀？\n\n开发大哥：我这周忙，下周吧。\n\n产品：用户可能比较着急，这周就要呢！\n\n开发大哥：我知道，做不完啊！\n\n于是开始了经典的产品开发撕逼大战。。。\n\n![](https://qiniuyun.code-nav.cn/image-20210712141336633.png)\n\n鱼皮：要不我们把这个需求拆解为功能 A 和功能 B，这周我先把功能 A 做了，功能 B 排到下周二测试，下周四上线？\n\n就这样，我们一个个安排了需求的计划完成日期。\n\n\n\n### 设计阶段\n\n终于开完会了，看了下时间，都该下班了！\n\n唉，需求讨论完了，产品的工作是完成了一些，可鱼皮的工作才刚刚开始。\n\n急着开始写代码么？\n\n**不，想好怎么写代码比写代码更重要。**\n\n\n\n#### 架构设计\n\n鱼皮打开写文档软件和画图软件，开始梳理整个系统，从整体到局部，依次设计出系统的层次结构、各层间交互的接口和通讯方式、每层之间包含哪些重要模块、模块选择何种物理部署方式等。\n\n![知名框架 Dubbo 的架构设计](https://qiniuyun.code-nav.cn/693275-20180308155215280-770422402.png)\n\n\n\n#### 概要设计\n\n写完架构设计后，鱼皮开始对着产品妹子写的 PRD（产品需求文档），分析需求，然后依然是从整体到局部，先整理出系统需要的功能模块，再分析每个功能模块内有哪些子模块。\n\n和抽象的架构设计相比，概要设计和需求的关系更紧密，是对架构设计的细化。\n\n打个比方大家就明白了，你要盖一栋楼，架构设计就是从整体来考虑，总共有几层、每层管道怎么接、每层有几户、地基怎么打等；而概要设计就是考虑每户套件的内部怎么划分，哪里是客厅、哪里是卫生间。\n\n\n\n> 很多情况下，概要设计和架构设计可能会在一个文档中进行，划分并不明确。\n\n\n\n#### 详细设计\n\n想好系统有哪些功能后，鱼皮就开始具体分析每个功能如何实现，用到哪些算法、需要注重哪些细节等。\n\n\n\n#### 方案对齐\n\n写好设计文档后，下次会议上，鱼皮和其他的开发同学（前端、后端等）一起针对自己设计的方案展开讨论，最终产生一个统一的方案，然后大家分工去做就好了。\n\n\n\n#### 测试用例设计\n\n为了保证系统功能的正常稳定，测试同学（或者叫 QA）是非常重要的，测试不是像我们自己做项目一样对着网页点几下就 ok 了。\n\n在大公司中，为了保证测试的覆盖度、提高测试效率，一般是要设计测试用例的，比如：用户点击 “登录”，未传任何数据，期望结果是警告用户输入用户名和密码。\n\n![测试用例管理](https://qiniuyun.code-nav.cn/product-content-testcase-1X3-12439a68c4.png)\n\n测试用例设计完后，需要其他同学一起来评审把关，而不是只交给测试同学。因为一个人很容易忽略掉很多测试细节，最好让更熟悉代码的开发同学一起帮忙补充。\n\n鱼皮自己也写了几个测试可能会遗漏的用例，和测试同学一起进行了确认，尽量让问题暴露在测试阶段而不是线上。\n\n\n\n### 研发准备\n\n写了快一周的设计文档，终于准备开始动手搭建项目了。但在此之前，还有一些准备工作要进行。\n\n\n\n#### 技术预研\n\n如今技术发展太快，新技术层出不穷，所以鱼皮首先对项目中需要或可能需要用到的技术进行了调研。\n\n\n\n#### 技术选型\n\n通过调研，鱼皮得到了几个可以满足需求的技术，但他开始纠结：这么多技术，我该用哪一个呢？是用 SSM 框架还是 Play 框架呢？用 guava 包还是 Apache Commons 呢？\n\n鱼皮又打开了写文档软件，开始对比不同技术的优劣，头疼啊，技术选型要考量的因素太多了，比如：\n\n- 单从技术考虑：性能、易用性、稳定性、主流程度和生态、文档详细度\n- 结合团队：团队成员对技术的熟悉度、掌控度（有无精通该技术的人）\n- 结合业务：是否适应业务的量级（单机 or 微服务）、是否适应业务（读多、写多 or 分析多）\n\n\n\n对于关键的项目，鱼皮自己还不敢完全确定选型，因此在写好自己的选型文档后，与同事和 Leader 一起讨论，才最终确认。\n\n\n\n#### 资源申请\n\n确认好技术后，就要申请资源。比如鱼皮用到了 MySQL 数据库，但是这个 MySQL 从哪儿来呢？\n\n以前的话，鱼皮都是去买一台云服务器，自己搭建 MySQL。但是在企业中，一般是有集中管理和分配资源的平台的，直接到平台填写预算、等领导审批、然后等着下发资源就好了。千万不能私自用自己的或买外部的服务器来部署项目，不安全！\n\n鱼皮这次直接申请到了 2 万多一年的云数据库，真的是爽死了。\n\n![](https://qiniuyun.code-nav.cn/image-20210712140804895.png)\n\n\n\n#### 环境准备\n\n申请好数据库等资源后，鱼皮按照申请机器的版本搭建了一模一样的本地开发环境和测试环境，后面就可以直接连接了。\n\n\n\n#### 项目初始化\n\n环境准备妥当后，由于是新项目，鱼皮要搞一个最小可运行的初始化项目 Demo，使用 **脚手架** 自动生成代码，而不是从零开始一个个新建文件、手敲重复代码。\n\n\n\n#### 依赖安装\n\n生成了项目代码后，鱼皮使用包管理工具（前端 yarn、Java Maven /  Gradle 等）自动安装依赖，然后项目 Demo 就可以运行啦！\n\n\n\n### 研发阶段\n\n前期准备完成后，这才到了程序员朋友们最熟悉的写代码环节，也是鱼皮最爱的环节。\n\n![](https://qiniuyun.code-nav.cn/image-20210712140724830.png)\n\n因为之前设计方案时需要保持冷静、仔细思考，没法边听歌儿边做；而方案设计好后，已经明确了该怎么做，写代码实现就很简单了，顶多是遇到一些坑，上网搜索去解决就好了。\n\n\n\n#### 本地开发\n\n开发时，一般鱼皮会先在本地写代码，通过配置热更新工具，实现代码更新时自动重新编译打包，而不用手动重启项目，大大提高了开发效率。\n\n对了，企业开发都会使用版本控制系统的，比如 Git，开发前记得先创建一个自己的分支，在这个分支上开发。\n\n\n\n#### 远程开发\n\n现在还有一种比较流行的远程开发方式，就是可以像编辑本地文件一样编辑远程文件，直接修改服务器上的代码。一般我们每位研发同学是有自己的开发机的，通过远程开发就省去了反复部署调试的麻烦，提高效率。一般用 VSCode 等开发工具，安装远程开发插件就可以实现了。\n\n\n\n#### 代码优化\n\n鱼皮在写代码的时候，始终保持主动优化代码的好习惯，注重代码的时空复杂度；并且当重复代码多了，会想办法抽象成函数或者使用设计模式。之前专门写文章分享过我的编程习惯：[我写代码时的小倔强](https://mp.weixin.qq.com/s/df5JMmBbw294y2sAPMwGbA) 。\n\n\n\n#### 单元测试\n\n注意！不要听到测试就以为是测试同学的工作，开发同学也同样需要编写小粒度的测试来为自己的代码负责。\n\n鱼皮一般会为每个数据库读写函数和业务逻辑函数编写单元测试，像 Java 的话一般用 JUnit 等工具，还可以用 Jacoco 生成测试覆盖度报告。每次修改关键代码后，都要执行一遍单元测试，防止意外错误。\n\n![Jacoco 测试覆盖度报告](https://qiniuyun.code-nav.cn/image-20210712140554038.png)\n\n\n\n#### 开发联调\n\n鱼皮终于写好了后端代码，也自测完成了，下面就是把写好的代码打包构建，然后把可执行项目包发布到测试服务器上，和前端同学一起联调，让他请求我的接口，验证系统的功能是否可用。\n\n\n\n### 测试验证\n\n鱼皮和前端联调完毕后，告知了测试和产品同学。\n\n测试验证是企业中至关重要的环节，甚至可以说是最后一道防线。测试的目的是找 Bug，尽量发现系统中的问题，把它们扼杀在测试阶段。\n\n在企业中，测试验证又有很多类型。\n\n\n\n#### 集成测试\n\n集成测试比单元测试粒度更大，是把多个模块或代码单元放在一起，验证模块之间的集成和调用关系。\n\n因为单个函数的执行可能是正常的，但把多个函数组合在一起顺序调用，可能就会出现问题。\n\n打个比方，我们有个吃面包系统：\n\n功能 A：小鱼吃一个面包\n\n功能 B：小皮吃一个面包\n\n每次只有一个面包，独立执行功能 A 和 B 都是允许的。但如果两个一起执行，后执行的那个功能就会报错。\n\n![](https://qiniuyun.code-nav.cn/image-20210712140428508.png)\n\n\n\n#### 系统测试\n\n系统测试比集成测试的粒度更大，测试对象是整个系统，不仅包括软件，还可能覆盖对硬件的测试。\n\n\n\n#### 产品体验\n\n除了测试同学要验证系统可用性，产品妹子也要体验下功能是否符合预期、是否易用。大多数情况下，产品会在体验时提出修改建议，开发可能还要再去做一些修改。\n\n\n\n#### 验收测试\n\n测试和产品妹子终于表示没有问题啦，那就到了最后一步，把整个产品或功能给最终的用户来体验。~~老板~~ 用户说没问题，才是真的没问题！\n\n\n\n### 提交阶段\n\n系统没问题之后，鱼皮就可以把代码发布到远程仓库了，一般使用 Git 和 SVN 等版本控制系统。\n\n\n\n#### 代码提交\n\n鱼皮首先在本地触发代码提交（git commit），为保证规范，在大项目中一般会使用提交检测插件，防止你把错误的代码进行了提交。\n\n\n\n#### 代码推送\n\n下一步就是把本地的提交推送到远程的同名分支。一般大厂会有推送检测工具，检测代码的错误、圈复杂度、代码规范等，和提交检测一样，防止你把错误或不规范的代码进行了推送。\n\n\n\n#### 合并请求\n\n代码分支推送到远程之后，鱼皮发起了一个分支合并请求（MR），希望把该分支的代码合并到主干分支（没问题的代码）。\n\n![发起新合并请求](https://qiniuyun.code-nav.cn/image-20210712140308463.png)\n\n#### 代码审查\n\n并不是发起了合并请求就能直接合并，还要通过代码审查，即 CR。\n\n审查又分为两种方式：人审和机审。\n\n相信不少同学都知道人审，一般是由你的上级和其他项目负责人来阅读和评论你的代码，觉得没问题就 Approve（通过），否则打回去修改。\n\n那机审是个啥呢？其实就是机器自动检测你的代码是否符合规范，是否能够成功自动化构建等，一般是由项目负责人配置的，可以帮助发现一些人工难以发现的问题。\n\n刚接触新项目的时候，鱼皮经常被机审折磨得苦不堪言，经常被提示一些莫名其妙的代码问题，比如加号要换行，文件行末要加空行等。但后来注意编码习惯后，就很自然地适应了，的确不错。\n\n\n\n### 发布阶段\n\n代码审查通过后，鱼皮的项目代码就可以发布上线啦。\n\n![](https://qiniuyun.code-nav.cn/image-20210613143744811.png)\n\n\n\n#### 打包构建\n\n传统上线方式是开发人员到正式服务器上拉取代码，然后安装依赖，再通过工具把代码打包构建，得到部署包，通过 Nginx、Tomcat、Docker 等技术运行。\n\n但这样效率很低，有很多重复工作。所以大厂一般是用自动化构建的，像 Jenkins、各种 CI / CD 工具等。代码合并到主分之后，由机器把代码打包构建为最终的部署包。\n\n\n\n#### 预发布\n\n为了防止上线出问题，一般我们会先在预发布环境部署项目，再观察一下是否能够正常运行。\n\n\n\n#### 正式发布\n\n预发布测试正常后，鱼皮终于等到了上线的这一刻。大项目一般都会部署在多台机器上，所以不可能一台台登录机器去发布部署包。\n\n通常公司会提供可视化发布平台，点选需要发布机器（一般先灰度，选一小部分机器，再全量发布），点击一键发布，等项目管理员审批通过之后，就交给机器自动部署吧！\n\n\n\n### 后续\n\n鱼皮曾天真地以为项目上线之后，就可以高枕无忧了。但后来发现，项目上线之后，同样需要保持警觉。虽然已经测试过，但仍然时不时会出现个预期之外的小 Bug，还是很考验心态的。\n\n![](https://qiniuyun.code-nav.cn/image-20210712140135097.png)\n\n来看看上线之后，鱼皮做了哪些事呢？\n\n\n\n#### 监控运维\n\n鱼皮会定期查看项目的监控面板，观察项目的运行情况，机器的负载等。\n\n\n\n#### 统计分析\n\n鱼皮在代码中添加了一些日志，可以利用 ELK 等日志收集可视化平台对这些日志进行分析，从而感知到用户的行为，进一步优化业务和系统。\n\n比如我会统计用户执行 SQL 查询的耗时，对重复率高的慢 SQL 进行针对性地优化。\n\n\n\n#### 事件反馈\n\n有的时候，用户自己都不能清楚地描述 Bug，而且历史 Bug 也不方便找到。所以公司内部一般会有事件反馈平台，产品等内部同学在接收到 Bug 时，会在该平台发布一个 Bug 事件，详细描述 Bug 出现的时间、状况、详情等，便于我们开发集中分析和处理问题。\n\n![事件反馈平台](https://qiniuyun.code-nav.cn/image-20210712140028393.png)\n\n\n\n#### 文档沉淀\n\n每次上线了新功能和项目，鱼皮都会通过写文档来记录项目的背景、设计方案、开发过程和一些坑点，便于后续其他同学了解项目，这是非常重要的！利人利己。\n\n曾经分享过我的写文档技巧：[如何写好文档？](https://mp.weixin.qq.com/s/oQTksFE-cPYRKGJnr71-kw)\n\n\n\n#### 迭代优化\n\n最后，一个需求的结束往往只是另一个需求的开始。像鱼皮最近在跟进的项目，一期做完做二期，二期还没做完三期就来了；还要抽出时间去优化以前的代码，这日子遥遥无期，没盼头啊！\n\n\n\n---\n\n\n\n看完本文后，欢迎阅读我之前的这篇文章：[大厂机密！30 个提升团队研发效能的锦囊](https://mp.weixin.qq.com/s/RyqO8ry29zAL40ToVitxTQ) ，了解更多大厂技术。\n\n', '2023-06-03 19:32:09', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (24, '我们公司的面试，有点不一样！', '朋友们周末愉快，我是鱼皮。因为我很屑，所以大家也可以叫我屑老板。\n\n自从我发了自己创业的文章和视频后，收到了很多小伙伴们的祝福，真心非常感谢！\n\n不得不说，有些同学是真有才啊，因为我公司叫 “鱼鸢网络”，就有同学把它称为 “鱼厂”。那 “鸢”（yuan）还有鸟的意思呢，可以考虑叫 “鸟厂” 哈哈？\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230422215203253.png)\n\n言归正传，开了公司后，我收到最多的评论和私信就是：鱼厂公司什么时候招人？公司是怎么招人的？\n\n其实之前我也说了，我们公司的员工在我离职前就已经招好了，今天给大家分享一下我们公司招开发的过程。\n\n不能说是史无前例，但也绝对和大多数公司的招聘方式不一样。\n\n**因为，我们不仅没有笔试！也没有面试！**\n\n为什么呢？这里就要先说一下我的招人标准了，用五个字来概括就是 “要能干好活”。\n\n说白了，就是我要知道这个求职者不仅能够完成我的工作、完成我们项目的需求；还要态度认真、做事仔细，能把工作完成的很好，不能一上线就一堆 Bug。\n\n那我就在思考，怎么样才能保证自己招到的人符合这个要求呢？\n\n我的策略很简单：\n\n目标 1：我要足够了解这个人，确保他的做事态度是认真的\n\n策略：从我 [编程导航知识星球](https://mp.weixin.qq.com/s?__biz=MzI1NDczNTAwMA==&mid=2247539132&idx=2&sn=45af016dee0c03491750f76ba8fdbd25&chksm=e9c2be4bdeb5375d3253155b4053263109a631620b7cb9074e2fe1b4a5b1604ef92c522b606e&token=145986907&lang=zh_CN#rd) 里的同学招募，因为首先星球里的人学习态度都很认真，而且可以直接根据他在星球里的往期发文来看出他个人的学习态度和做事风格\n\n目标 2：我要确认他能够完成项目开发工作\n\n策略：区别于传统的笔试和面试题目，我直接在星球发布一个实际工作中可能要做的小项目（小问题）给大家去完成，根据大家的解决方案、作品和代码来综合评估大家的项目能力。\n\n我不管你的学历如何、不管你八股文背的怎么样，只要你能够认真地完成我们项目的需求、能干好活，就足够了。\n\n确定了这两个策略，我就在星球里发布了两个招募帖：\n\n前端招募：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230422214517713.png)\n\n前端考核任务：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230422214535875.png)\n\n后端招募：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230422214615327.png)\n\n大家也可以思考一下这两个考核任务自己能否完成，应该难度是不大的，星球里完成的同学也不少。但毕竟我们招募人数有限，“完成” 和 “做得好”，我们当然要后者。\n\n最终我成功招募到了前端开发同学。但可惜的是，后端开发同学还没有招到满意的，近期很可能还会在星球发一个后端实习生的招募，招募方式应该也是类似的。到时大家如果感兴趣的话，欢迎来尝试！\n', '2023-06-03 19:32:09', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (25, '面了个 Java 实习生，小伙很优秀！', '大家好，我是鱼皮，前几天给自己的公司面试了一位 Java 暑期实习生，候选人目前是大三。\n\n整个过程我都录屏了，并且在征得候选人的同意后，把面试过程分享出来。一方面是希望对其他在学编程找工作的小伙伴有一些启发和参考，另一方面也是希望大家给屑老板一些建议，让我也能成为一个更好的面试官。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230518161120025.png)\n\n以下是面试过程视频，整个面试时长大概 40 分钟，我精简了一些内容，但依然有点儿长，大家可以先收藏起来慢慢看~\n\n视频：https://www.bilibili.com/video/BV1Ps4y1M7cY\n\n虽然很多朋友参与过面试，但是应该很少有作为面试官去面试别人的经验，下面我就给大家简单分享下我作为面试官的心路历程。\n\n首先，由于我也是第一次这么正经地作为面试官，所以其实也是有点儿小紧张的。\n\n> 希望大家面试也不要紧张，可能面试官比你还紧张哈哈，就当和面试官交流技术了~\n\n大家信任我，来投递我这么一家小公司，又满怀期待地参与面试，我必须得积极回应下对吧！所以我的想法是：通过这场面试，哪怕最终这位候选人的表现没有符合我们的要求，也要让他能学到一些东西，对他之后的学习有一些正向的影响。\n\n因此，和我自己经历过的大多数面试不同，除了按照候选人的简历从上到下依次提问外，我基本上每问一个问题，都会解释一下我为什么要问这个问题，让候选人 get 到面试官的思路。此外，如果候选人不能很好地回答问题，我会给他一些小的引导（比如举个例子之类的），并且在他回答完后分享一下我想听到的答案。\n\n结果，这位小伙子整个面试的表现都非常不错，最终被我们录取了~\n\n让我印象比较深刻的加分项有几点：\n\n1. 听完问题后再作答，而不是着急抢答，每个问题的回答时长也恰到好处\n2. 语言表达自然，虽然还是有点儿紧张（正常），但回答问题时的思路还是很清晰的\n3. 项目实践能力非常丰富，完全符合我们的工作需要\n\n目前这位小伙也已经在我司工作一周了，不仅工作态度认真、上手工作快、文档写得好，甚至还能够超出预期完成任务，针对一个问题提出多种不同的解决方案等。等他放假来线下了，必须加餐！\n\n以下是这位小伙伴入职后在编程导航星球发的一个面经，得到了候选人的肯定，屑老板还是挺开心的哈哈（我可没绑架他）！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230518160427926.png)\n\n> 星球原帖：https://t.zsxq.com/0e1PImfyg\n\n还有很多小伙伴问我还招不招人？\n\n至少我目前没有招新人的打算。因为招人本身不是一件随意的事，用工成本、管理成本、信任成本都要考虑。而且说实话，大家对我的期待有点太高了，我也是第一次开公司，而且也是个创业小公司，我每走一步都需要很谨慎。\n\n所以大家如果对我、对我们公司有什么好的建议呀，都欢迎评论区指正。如果屑老板真的做大做强了，肯定还会招人滴！感谢阅读。\n\n\n\n---\n\n\n欢迎学编程的朋友们加入鱼皮的编程学习圈子(https://yupi.icu) ，和上万名学编程的同学共享知识、交流进步，学习原创项目并享有答疑指导服务。', '2023-06-03 19:32:09', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (26, '什么是数据库事务？讲一下事务的 ACID 特性？【02.20 - 30天面试题挑战】', '# 什么是数据库事务？\n\n- 简单来说：事务通常是由一个或一组SQL组成的，组成一个事务的SQL一般都是一个业务操作，例如下单业务：「扣库存数量、增加订单详情记录、插入物流信息」，这一组SQL就可以组成一个事务。\n- 事务是由 MySQL 的引擎来实现的。\n- InnoDB 引擎它是支持事务的，MySQL 原生的 MyISAM 引擎就不支持事务。\n\n# 讲一下事务的 ACID 特性？\n1. **原子性（**A**tomicity）**\n一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样\n    > 买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。\n2. **一致性（**C**onsistency）**\n是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。\n    > 用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。\n3. **独立性/隔离性（**I**solation）**\n数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。\n    > 消费者购买商品这个事务，是不影响其他消费者购买的。\n4. **持久性（**D**urability）**\n事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。', '2023-06-03 19:32:09', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (27, '专题一：日期问题', '# 前言\n\n在专题一种我们主要讲解关于日期的问题，比较基础但是一定要掌握！！在**蓝桥杯**竞赛中，常会考到一些日期日历的问题，出现在填空题或者编程的前几题，因此巩固好基础更加有助于我们在比赛中遇到类似的题时游刃有余。下面来枚举一些例题与蓝桥杯的真题。格式会按照：**题目—题解—知识点**，十分清晰！！废话不多说，先上模板！！\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/uh5Cu2jY-image.png)\n\n# 模板\n\n非常重要！！可以说**背下来**可以做出来％90的日期日历的问题！\n\n```C++\n#include <iostream>\nusing namespace std;\n\nint months[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n// 判断日期的合法性\nbool check_valid(int date) //形如20210305\n{\n    int year = date / 10000;\n    int month = date % 10000 / 100;\n    int day = date % 100;\n\n    if (month <= 0 || month >= 13) return false;\n    if (day == 0 || month != 2 && day > months[month]) return false;\n\n    if (month == 2)\n    {\n        int leap = (year % 4 == 0 && year % 100 != 0 || year % 400 == 0);\n        if (day > 28 + leap) return false;\n    }\n\n    return true;\n}\n\n// 得到某年某月的天数\nint get(int year, int month) \n{\n    if (month != 2) return months[month];\n    else\n    {\n        // 2月\n        int leap = (year % 4 == 0 && year % 100 != 0 || year % 400 == 0);\n        return 28 + leap;\n    }\n}\n\n// 判断两个日期之间有多少个回文日期\nint get(int date1, int date2, int k) //k使函数签名不同从而编译通过\n{\n    int ans = 0;\n    for (int i = 1000; i < 10000; i++)\n    {\n        int date = i, x = i;\n        for (int j = 0; j < 4; j++) date = date * 10 + x % 10, x /= 10; //根据年份构造出回文日期\n        if (date1 <= date && date <= date2 && check_valid(date)) ans++; \n    }\n\n    return ans;\n}\n\n// 给定年月日，经过n天后对应的日期\nvoid pass(int y, int m, int d, int n)\n{\n    while (n--)\n    {\n        d++;\n        if (d > get(y, m)) m++, d = 1;\n        if (m > 12) y++, m = 1;\n    }\n    printf(\"%d-%02d-%02d\\n\", y, m, d);\n}\n\n\n\n```\n\n\n\n# 1、回文日期-1\n\n\n\n![image_8DQXwLdh4f.png](https://pic.code-nav.cn/post_picture/1612112775822180354/i0qkvjFW-image_8DQXwLdh4f.png)\n\n![image_F5qCyEFE0r.png](https://pic.code-nav.cn/post_picture/1612112775822180354/KkZ8UvYj-image_F5qCyEFE0r.png)\n\n## 代码\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint months[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\n//判断日期是否合法的模板，背诵！！\nbool check(int date)\n{\n    int year=date/10000;\n    int month= date%10000/100;\n    int day = date%100;\n \n    if(!month||month>=13||!day) return false;\n    if(month!=2&&day>months[month]) return false;\n \n    if(month==2)\n    {\n        bool leap = year%4==0 &&year %100!=0 || year %400==0;\n        if(day>leap+28) return false;\n    }\n \n    return true;\n}\n\n\nint main()\n{\n    int data1,data2;\n    cin>>data1>>data2;\n \n    int res=0;\n    for(int i=0;i<10000;i++)\n        {\n            int x=i,r=i;\n            for(int j=0;j<4;j++) r=r*10+x%10,x=x/10;//回文串转换的算法\n            if(r>=data1&& r<=data2 && check(r)) res++;\n        }\n    cout<<res<<endl;\n    return 0;\n}\n\n```\n\n## 题解\n\n由于只有八位数，且回文串左右对称，因此可以只枚举左边，这样只需要枚举0~9999\n\n然后判断：\n\n1. 整个八位数构成的日期是否合法\n2. 是否在范围内\n\n**本题思维在于枚举所有回文数再去筛选出符合要求的。**\n\n知识点：\n\n1. 判断日期是否合法的模板\n2. 回文串转换算法\n\n\n\n# 2、日期识别\n\n![image_kw0EJjwrmn.png](https://pic.code-nav.cn/post_picture/1612112775822180354/pJkhQ91H-image_kw0EJjwrmn.png)\n\n![image_wTHGGecViR.png](https://pic.code-nav.cn/post_picture/1612112775822180354/u0Uo5MA9-image_wTHGGecViR.png)\n\n## 代码\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\n\nstring month[13]={\"\",\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"};\nint main()\n{\n   string st;\n   int m,d1,d2;\n   cin>>st;\n   for(int i=1;i<=12;i++)\n        if(st.substr(0,3)==month[i])\n        {\n            m=i;\n            break;\n        }\n    d1=st[3]-\'0\';\n    d2=st[4]-\'0\';\n    cout<<m<<\" \";\n    if(d1!=0) cout<<d1;\n    cout<< d2;\n}\n```\n\n## 题解\n\n本题主要就是枚举，再加上一些字符串处理的知识，并没有什么思维上的难度。\n\n知识点：\n\n1. substr函数：返回从某个位置后指定长度的子串\n2. 字符转成数字的操作\n\n\n\n# 3、日期类\n\n\n![image_xkj-5iiRs9.png](https://pic.code-nav.cn/post_picture/1612112775822180354/ArlJGuci-image_xkj-5iiRs9.png)\n\n## 代码\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint a[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\nint main()\n{\n    int n,y,m,d;\n    cin>>n;\n    while(n--){\n        cin>>y>>m>>d;\n        if(y%4==0&&y%100!=0||y%400==0)a[2]=29;\n        else a[2]=28;\n        d++;\n        if(d>a[m]){\n            m++;\n            d=1;\n        }\n        if(m>12){\n            m=1;\n            y++;\n        }\n        if(y<10)cout<<0;\n        cout<<y<<\'-\';\n        if(m<10)cout<<0;\n        cout<<m<<\'-\';\n        if(d<10)cout<<0;\n        cout<<d;\n        cout<<endl;\n    } \n    return 0;\n}\n\n```\n\n## 题解\n\n变量是：y=year m=month  d=day\n\n然后我们判断，只要我们的天数大于了这个月的天数，我们就要把月份m++，并且把日回到1号\n同理只要我们的月数大于了12，我们就要把年份y++，并且把月份回到1月\n\n接下来我们还要考虑一个问题，就是一位数前加0（输出格式）\n我们只要一次判断即可：只要y是一位数，先输出个0，日也是一样的做法。\n\n知识点：\n\n1. 算天数模板的运用\n2. 判断闰年\n\n\n\n\n\n# 4、打印日期\n\n\n![image_UxZ4jtKlmW.png](https://pic.code-nav.cn/post_picture/1612112775822180354/WY21mNXp-image_UxZ4jtKlmW.png)\n\n\n![image_ixcooYY5Yp.png](https://pic.code-nav.cn/post_picture/1612112775822180354/2Tfzyjkc-image_ixcooYY5Yp.png)\n## 代码\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint a[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\nint main()\n{\n    int y,d;\n    //输入多行数据\n    while(cin>>y>>d){\n        //获得二月的天数\n        if(y%4==0&&y%100!=0||y%400==0)a[2]=29;\n        else a[2]=28;\n        int m=1;\n        while(d>0){\n            if(d-a[m]<=0)break;\n            else{\n                d-=a[m];\n                m++;\n            }\n        }\n        printf(\"%04d-%02d-%02d\\n\",y,m,d);//数据宽度不足时用0填补\n    }\n}\n\n```\n\n## 题解\n\n先把每个月的天数给列下来，再判断闰年。\n最后我们来统计是几月几日，如果减去m月的天数，就比0要小了，我们就赶快退出\n如果不会的话，月份+1，并且减去m月的天数。\n\n知识点：\n\n1. 格式输出大法：printf(\"%04d-%02d-%02d\\n\",y,m,d);\n2. 判断闰年\n\n\n\n\n\n# 5、日期\n\n\n![image_5wlbv3TwGD.png](https://pic.code-nav.cn/post_picture/1612112775822180354/MR1FvJa0-image_5wlbv3TwGD.png)\n\n## 代码\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint a[13]={0,31,29,31,30,31,30,31,31,30,31,30,31};\nstring week[7]={\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\",};\nint main()\n{\n    int n,m,day1=0,day2=0;\n    cin>>n>>m;\n    for(int i=1;i<4;i++)day1+=a[i];\n    day1+=12;\n    for(int i=1;i<n;i++)day2+=a[i];\n    day2+=m;\n    cout<<week[(day2-day1)%7];\n}\n\n```\n\n## 题解\n\n本题思维点在于把星期四当成第一天，然后计算出给出的日期与第一天的差值，再利用取模的算法求出是星期几，如果对取模算法不熟悉的话需要自行在草稿纸上模拟一遍，并记下这个结论。\n\n知识点：\n\n1. 打表，将星期四作为第一天\n2. 取模运算求出是星期几\n\n\n\n\n\n# 6、日期计算\n\n\n![image_plw0op1pYi.png](https://pic.code-nav.cn/post_picture/1612112775822180354/4bd7A55f-image_plw0op1pYi.png)\n\n![image_nCOo4tQrC-.png](https://pic.code-nav.cn/post_picture/1612112775822180354/ZYpfRM27-image_nCOo4tQrC-.png)\n## 代码\n\n### 解法一：模板法\n\n```C++\n#include <iostream>\nusing namespace std;\n\nint months[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n// 得到某年某月的天数\nint get(int year, int month)\n{\n    if (month != 2) return months[month];\n    else\n    {\n        // 2月\n        int leap = (year % 4 == 0 && year % 100 != 0 || year % 400 == 0);\n        return 28 + leap;\n    }\n}\n\n// 给定年月日，经过n天后对应的日期\nvoid pass(int y, int m, int d, int n)\n{\n    while (n--)\n    {\n        d++;\n        if (d > get(y, m)) m++, d = 1;\n        if (m > 12) y++, m = 1;\n    }\n    printf(\"%d\\n%d\\n\", m, d);\n}\n\nint main()\n{\n    int y, n;\n    cin >> y >> n;\n    int m = 1, d = 0;\n    pass(y, 1, d, n);\n    return 0;\n}\n\n\n```\n\n### 思维法：\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\nint a[13]={0,31,28,31,30,31,30,31,31,30,31,30,31};\nint main()\n{\n    int y,d;\n    cin>>y>>d;\n    if(y%4==0&&y%100!=0||y%400==0)a[2]=29;else a[2]=28;\n    int x=0;\n    while(d>0){\n        if(d-a[x]<=0)break;\n        else{\n            d-=a[x];\n            x++;\n        }\n    }\n    cout<<x<<\'\\n\'<<d;\n}\n\n\n```\n\n## 题解\n\n本题考察日期计算的方法，可以套用模板，也可以用思维法减少代码量，看个人喜好。\n\n知识点：\n\n1. 得到某年某月某日的天数\n2. 计算给定年月日，经过n天后对应的日期\n\n\n\n# 7、特殊年份—蓝桥杯十二届真题\n\n\n![image_xATHh4b7-k.png](https://pic.code-nav.cn/post_picture/1612112775822180354/K3BttOjX-image_xATHh4b7-k.png)\n\n## 代码\n\n```C++\n#include<bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n    int count=0;\n    for(int i=0;i<5;i++)\n    {\n        string s;\n        cin>>s;\n        if(s[0]==s[2]&&s[3]-s[1]==1)\n        {\n            count++;\n        }\n    }\n \n \n    cout<<count<<endl;\n \n}\n```\n\n## 题解\n\n水题一套，只要会字符串处理即可AC\n\n\n\n# 7、回文日期-2\n\n\n![image_gN7OPu6RwK.png](https://pic.code-nav.cn/post_picture/1612112775822180354/5Q9RmDCt-image_gN7OPu6RwK.png)\n\n![image_eT1jL6BF79.png](https://pic.code-nav.cn/post_picture/1612112775822180354/1PTpuzFI-image_eT1jL6BF79.png)\n## 代码\n\n```C++\n#include <iostream>\nusing namespace std;\n\nint months[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n// 判断日期的合法性\nbool check_valid(int date) \n{\n    int year = date / 10000;\n    int month = date % 10000 / 100;\n    int day = date % 100;\n\n    if (month <= 0 || month >= 13) return false;\n    if (day == 0 || month != 2 && day > months[month]) return false;\n\n    if (month == 2)\n    {\n        int leap = (year % 4 == 0 && year % 100 != 0 || year % 400 == 0);\n        if (day > 28 + leap) return false;\n    }\n\n    return true;\n}\n\n// 判断date是否满足ABABBABA形式\nbool check(int date)\n{\n    int year = date / 10000;\n    int month = date % 10000 / 100;\n    int day = date % 100;\n\n\n    if (month % 10 == day / 10) return false; //A==B return false\n    if ((month % 10 == day % 10) && (month / 10 == day / 10)) return true;\n\n    return false;\n}\n\nbool st1, st2;\nint ans1, ans2;\n\nint main()\n{\n    int date;\n    cin >> date;\n\n    int year = date / 10000;\n    while (true)\n    {\n        int new_date = year, x = year;\n        for (int i = 0; i < 4; i++) new_date = new_date * 10 + x % 10, x /= 10; //构造回文日期\n\n        if (new_date == date)  //构造出来的是同一天\n        {\n            year++;\n            continue;    \n        }\n\n        if (check_valid(new_date))\n        {\n            if (!st1) st1 = true, ans1 = new_date;\n            if (!st2 && check(new_date)) st2 = true, ans2 = new_date;\n\n        }\n\n        year ++;\n        if (st1 && st2) break; //找到两个解则退出\n    }\n\n    printf(\"%d\\n%d\", ans1, ans2);\n    return 0;\n}\n\n\n```\n\n## 题解\n\n本题需要找到两个符合题目的答案，第一个是回文子串，第二个符合格式的回文子串。\n\n先构造回文子串\n\n用函数判断是不是合法日期，如果不是就跳到下一个。\n如果符合，那么第一个答案已经找到，即可标记为true，在去判断是否符合格式.\n\n最后找到两个答案就输出即可。\n\n知识点：\n\n1. 回文子串构造\n2. 判断合法日期\n3. 判断是否符合格式\n\n\n\n# 总结\n\n以上的题基本包含了所有会考到的日期日历问题，各位一定要**先把模板背熟**，再去**写例题**，不会的题一定要\n\n好好琢磨题解的思维以及需要掌握的知识点是否已经烂熟于心。开篇大吉，预祝各位考生考出好成绩！！\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/jxux7Zb3-image.png)\n\n', '2023-06-03 19:32:09', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (28, '专题二：二分法', '# 专题二：二分法\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/PyoV3oWo-image.png)\n# 前言\n\n本文主要介绍二分法是什么，二分法的原理，二分法的模板以及使用场景，并且会举一些例题和蓝桥杯真题辅助理解。\n\n# 是什么\n\n官方版：二分查找是一个时间效率极高的算法，尤其是面对大量的数据时，其查找效率是极高，时间复杂度是log(n)。 &#x20;\n主要思想就是不断的对半折叠，每次查找都能除去一半的数据量，直到最后将所有不符合条件的结果都去除，只剩下一个符合条件的结果。\n\n精简版：二分区间快速高效找到结果。\n\n# 模板\n\n## 查找大于等于/大于key的第一个元素\n\n这种通常题目描述为满足某种情况的最小的元素。\n\n```cpp\n   int left = 1,right = n;\n    while(left < right)\n    {\n        //这里不需要加1。我们考虑如下的情况，最后只剩下A[i],A[i + 1]。\n        //首先mid = i，如果A[mid] > key，那么right = left = i，跳出循环，如果A[mid] < key，left = right = i + 1跳出循环，所有不会死循环。\n        int mid = (left + right) / 2;\n        if(A[mid] > key)//如果要求大于等于可以加上等于，也可以是check(A[mid])\n            right = mid;\n        //因为找的是大于key的第一个元素，那么比A[mid]大的元素肯定不是第一个大于key的元素，因为A[mid]已经大于key了，所以把mid+1到后面的排除\n        else\n            left = mid + 1;\n        //如果A[mid]小于key的话，那么A[mid]以及比A[mid]小的数都需要排除，因为他们都小于key。不可能是第一个大于等于key的元素，\n    }\n\n```\n\n## 查找小于等于/小于key的最后一个元素\n\n这种通常题目描述为满足某种情况的最大的元素.\n\n```cpp\n    int left = 1, right = n;\n    while(left < right)\n    {\n        //这里mid = (left + right + 1) / 2;\n        //考虑如下一种情况，最后只剩下A[i],A[i + 1]，如果不加1，那么mid = i，如果A[mid] < key，执行更新操作后，left = mid，right = mid + 1，就会是死循环。\n        //加上1后，mid = i + 1,如果A[mid] < key，那么left = right = mid + 1,跳出循环。如果A[mid] > key，left = mid = i，跳出循环。\n        int mid = (left + right + 1) / 2;\n        if(A[mid] < key)\n            left = mid;//如果A[mid]小于key，说明比A[mid]更小的数肯定不是小于key的最大的元素了，所以要排除mid之前的所有元素\n        else\n            right = mid - 1;//如果A[mid]大于key，那么说明A[mid]以及比A[mid]还要大的数都不可能小于key，所以排除A[mid]及其之后的元素。\n    }\n\n\n```\n\n# 判断二分的特性\n\n1.  单调性：数组具有明显的单调性\n2.  二段性：答案在一段区间内，二分答案\n\n# 分类\n\n-   二分查找：在一个已知的有序数据集上进行二分地查找\n-   二分答案：答案有一个区间，在这个区间中二分，直到找到最优答案\n\n# 二分思考顺序\n\n首先通过题目背景和check(mid)函数的逻辑，判断答案落在左半区间还是右半区间。\n\n左右半区间的划分方式一共有两种：\n\n中点mid属于左半区间，则左半区间是\\[l, mid]，右半区间是\\[mid+1, r]，更新方\n\n式是r = mid;或者 l = mid + 1;，此时用第一个模板；\n\n中点mid属于右半区间，则左半区间是\\[l, mid-1]，右半区间是\\[mid, r]，更新方\n\n式是r = mid - 1;或者 l = mid;，此时用第二个模板\n\n（第一个找符合要求的最小值，第二个找符合要求的最大值）\n\n# 力扣704：二分查找\n\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/eLMZuUV0-image.png)\n\n## 代码\n\n```cpp\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n\n        int l=0,r=nums.size()-1;\n        while(l<r){\n            int mid=(l+r)/2;\n            if(nums[mid]>=target) r=mid;\n            else l=mid+1;\n        }\n        if(nums[l]==target) return l;\n        return -1;\n    \n    }\n};\n```\n\n## 题解\n\n本题就是对模板的理解以及运用，属于是二分查找类型，因此用模板1或者模板2都是可以的，并不涉及最大值与最小值的问题。\n\n# 数的范围\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/VwILZO4c-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/3LPGwe53-image.png)\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100010;\nint q[N];\nint n,m;\n\nint main()\n{\n    cin>>n>>m;\n    for(int i=0;i<n;i++) cin>>q[i];\n    \n    while(m--)\n    {\n        int x;\n        cin>>x;\n        int l=0,r=n-1;\n        while(l<r)\n        {\n            int mid=l+r >>1;\n            if(q[mid]>=x) r=mid;\n            else l=mid+1;\n        }\n        \n        if(q[l]!=x) cout<<\"-1 -1\"<<endl;\n        else{\n            cout<<l<<\" \";\n            int l=0,r=n-1;\n            while(l<r)\n            {\n                int mid=l+r+1>>1;\n                if(q[mid]<=x) l=mid;\n                else r=mid-1;\n            }\n            \n            cout<<l<<endl;\n        }\n    }\n}\n```\n\n## 题解\n\n本题中的“起始位置”以及“最终位置”就分别对应最小值和最大值，因此对模板的理解要到位，第一个模板更新r向左边找的是找出最小值，第二个则是最大值，当然有可能是相等的情况以及找不到的情况。\n\n# 我在哪？\n\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/aTHXcf00-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/nyvEe7sI-image.png)\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nstring str;\nunordered_set<string> S;\n\n//找到任何两个长度为k的子串都不互相同\n//知识点：判断某个串是否只出现一次可以用哈希表\n\nbool check(int mid)\n{\n    for(int i=0;i+mid-1<n;i++)//区间大小为mid\n    {\n        string s=str.substr(i,mid);//取出子串\n        if(S.count(s)) return false;\n        S.insert(s);\n    }\n    \n    return true;\n}\n    \nint main()\n{\n    cin>>n;\n    cin>>str;\n    int l=1,r=n;//答案的区间\n    while(l<r)\n    {\n        int mid=l+r >> 1;\n        if(check(mid)) r=mid;\n        else l=mid+1;\n    }\n    \n    cout<<l<<endl;\n}\n```\n\n## 题解\n\n注意到本题属于是二分答案类型，答案是在一个区间里的，再根据题意要求出最小值选用第一个模板即可，\n\n本题需要掌握一个哈希表的知识点，可以用来快速判重，下次出一个专门的stl使用技巧，总结出所有常用的库以及函数。\n\n思维点：找到任何两个长度为k的子串都不互相同\n\n# 分巧克力\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/Izt9iZJu-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/uXAWWkrU-image.png)\n\n\n## 代码\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100010;\nint w[N], h[N];//存储长、宽\nint n,k;\n//因为答案在一个区间内：具有二段性，因此可以用二分答案法。\n\nbool check(int a){\n    int num=0;//切出的数量\n    for(int i=0;i<n;i++)\n    {\n        num+=(w[i]/a)*(h[i]/a);//推出的公式\n        if(num>=k) return true;\n    }\n    \n    return false;\n}\n\n\nint main()\n{\n    cin>>n>>k;\n    for(int i=0;i<n;i++) cin>>h[i]>>w[i];\n    \n    int l=1,r=1e5;//答案的区间\n    while(l<r)\n    {\n        int mid=(l+r+1) >>1;\n        if(check(mid)) l=mid;//因为求最大值\n        else r=mid-1;\n    }\n    \n    cout<<r<<endl;\n    return 0;\n}\n```\n\n## 题解\n\n本题注意到随着边长的增加，分的块数就会减小，满足单调递减的性质，考虑用二分出最大的边长。\n\n且答案在一个区间内，因此可以用二分答案的方法，再根据题目求最大值来选出用第二个模板。\n\n本题还需要推出一个可以切出巧克力块数的公式。\n\n# 机器人跳跃问题\n\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/PqcPTKO8-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/3lq1kLSC-image.png)\n\n## 代码\n\n```cpp\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 100010;\n\nint n;\nint h[N];\n\nbool check(int e)\n{\n    for (int i = 1; i <= n; i ++ )\n    {\n        e + = e - h[i];//每次失去或者得到能量\n       if (e >= 1e5) return true;//需要注意超过能量最大值的特判\n        if (e < 0) return false;\n    }\n    return true;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i ++ ) scanf(\"%d\", &h[i]);\n\n    int l = 0, r = 1e5;//\n    while (l < r)\n    {\n        int mid = l + r >> 1;\n        if (check(mid)) r = mid;\n        else l = mid + 1;\n    }\n\n    printf(\"%d\\n\", r);\n\n    return 0;\n}\n\n\n\n```\n\n## 题解\n\n本题还是有一定难度的，首先你需要想到可以用二分答案法来写，因为答案在一个区间内，并且不管你是得到还是失去能量都可以用一个表达式来表示，只不过可以是正也可以负值罢了，再去判断是否有一步走了会小于0，如果小于0了就不符合。本题还需要注意不能超出能量最大值。\n\n# 总结\n\n本文主要介绍了二分法，重点需要掌握二分的两个模板和理解方法，灵活运用到题目中还需大家多做题，增加自己的理解力和敏锐度。预祝各位考出好成绩！\n\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1612112775822180354/d6g5W32F-image.png)', '2023-06-03 19:32:09', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (29, '第一次做心理咨询，真的很有感触。。。', '	这个月因为自身的感情问题（其实属于单相思），导致了半个多月的无心学习状态，自己也是一直在自我的内耗里，总是走不出那种迷茫和痛苦里。不过时间拉长，很多东西也放下，包括我哥找了公司的心理咨询给我，开始想明白很多事情，还有自己人生的一些思考和指导。虽然说现在还没有完全恢复过来，但，想以此总结一下这次心理咨询的内容，调整回来，找到自己。\n	一开始医生（其实叫姐姐也可以，因为其实就聊聊天那种）就简单让我自己介绍一下自己，说明一下现在自己的什么情况之类，然后就问我有什么能够想不开的，我就也告诉了医生自己的情况，包括相遇，那一个多月跟她做过哪些事情，经历了一些对于我来说真的很特别的事情，然后最近什么情况，医生有帮我逐步分解，理顺我的思路。期间我说着说着就是哭着说了那些经历，真的真的很破防，因为这些事情我又不愿意在兄弟面前哭着说，也不想告诉家里人，这时候有个能够理解你的陌生人愿意听，真的就一下就崩溃了。然后医生会帮我分析了一下这个女生的性格为人，还有我自己的性格和情况，因为我们总是认不清自己是一个什么样的人，只有别人才能看明白，所以我也算是明白有的女生就是没有边界感，真的觉得打打闹闹好像，做一些亲密的动作没什么（互相躺在对方腿上都有过！！），但是对于我这种没有什么感情史的人来说，真的很容易陷进去。对于她们那类人来说，只是需要一个感情的陪伴，而不是所谓的爱情，尤其是其中一句话：如果你真的和她在一起了，有一天你跟她吵架，然后她跑去跟另一个男的两个人，找到天台聊到凌晨两三点，你会怎么想？这个问题之后，我才慢慢的想清楚。。。\n	后面呐就慢慢过渡到我自己本身，医生也说了，我把别人看得比自己重太多了，我需要以自己为主，然后问了我一个特别需要深思的问题，就是：你靠什么能够吸引另一半，甚至恋爱到结婚之后，仅仅只用喜欢吗？能这样做的人多得是，为什么她偏偏要跟你在一起呐？是的，只有让自己变得优秀，变得更加全面，变得更好，变得更强，才有选择的权利......\n	下面就是我咨询了一下我上个月的学习状态，如果有球友就知道我上个月其实学的很拼，并且写了一个学习计划，教大家如何做计划那种，也上了周精选，但是没想到就坚持了一个月，很尴尬。然后我问了那个医生，她说你那样的学习方式其实是不对的，违背人的正常心理状态，这样坚持一个月已经很牛掰，而且压抑自己的内心需求反而爆发的时候就很难收住，跟我讲了如何去调整自己的计划，也是那句话，生活不是只有工作和学习，还有诗和远方那种。不过因人而异，因为我是一个比较害怕孤独的人，所以我是需要有一点兴趣爱好支撑自己，所以这里如果各位已经找到适合自己的生活方式，就不用理会我这段话。\n	如何规划呐，主要是就是三个地方吧！\n	一、什么才是目标：找到一个好工作，留在大城市，这些都不应该成为学习的目的，这些目标太大太远，而且很容易放弃，坚持不了长久，可以改成一年比一年好，然后再下分几个月，或者每个月想学会什么，想做什么之类。我感觉跟我之前定目标有异曲同工的意思，只是需要把目标定的能够更加舒适。\n	二、计划不能太满：我之前的计划早上下午晚上都有，计划的东西，我的思想变成，我要去完成它，这是不对的，真正的是由自己的思想去做这个事情，而不是被计划牵引过去。我哥说的意思可以变为状态，早上下午状态好，那就用来学习，晚上状态不好，那就不学，直接去干自己喜欢的事情（我达不到鱼皮哥的那种状态），例如我喜欢摄影，那我就晚上跑去外面拍照之类的就OK，其实就是认清自己，还是要认识自己是怎样的人。还有我哥说了一句话，也是计划还有生活的一种冥冥之中的道理，可以用在很多地方，这句话是：可以追求，但是不强求。\n	三、全面发展：学习只是现在我主要提升自己的方式，还有其他东西也是需要的，例如身体，那我可以健身呀什么的，那在健身的时候，我去搜索如何健身，还可以在以后如果不想干编程，我去成为一个健身博主之类的，也是一种选择，而且现在女生不都喜欢腹肌那些嘛，那，是吧，也是提升自己吸引力的东西。还有其他的，例如做饭，摄影，剪视频，这些都是很好的加分项，这些都是能够吸引女生的一种方式，所以，全方面发展很重要。\n    最后做个小总结，开心和痛苦都会有对立面，我记得前段时间一个球友就发过b站那个视频，所以我们在特别开心和痛苦都不能太极端，这样才能保持更好的生活，还有一点，大家不要认为心理咨询有什么问题，其实跟本不能叫医生，更多的是聊聊天，而且是真的舒服，能迅速的走出或者找到一个方向去解决当下的问题，很多问题其实我们都知道解决方案，但是犹豫不决，而且不知道怎么执行下去，这时候就需要一些咨询帮忙，我好多出来上班的哥哥姐姐都去做过，是真的挺好的。\n	这里也祝大家有情人终成眷属，也能早日完成自己的目标，找到自己的人生意义！！\n', '2023-06-03 19:32:09', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (30, '极简typescript入门', '### 名词解释\n\n1. JS：JavaScript缩写\n2. TS：TypeScript缩写\n\n### 先说结论\n\n1. JS能做的事情，TS都能做，TS只是给JS增加了类型，地球人都知道JS是一门弱类型语言，非常灵活的同时，缺点也很明显，这意味着JS在运行时可能会出现类型错误。TS 提供了静态类型检查，有助于在编译阶段捕获类型错误。这可以防止运行时出现许多类型错误，并帮助开发人员编写更可靠的代码。\n\n### 如何学习？\n\n本文通过技术蛋老师的一个视频进行学习，具体学习步骤就是，通过做一个小项目，进行学习TS，理解为什么需要TS，JS的缺点，TS的优点等等！\n\n#### 项目介绍\n\n1. 一个很简单的表单增删功能操作，通过调用接口获取数据，然后渲染，\n2. 通过 TS 来约束变量，方法的行为，提高代码的可读性\n\n#### 步骤\n\n1. 全局安装 TS 命令： `npm i typescript -g` (mac不同)\n2. 创建一个TS文件，创建并打印一个变量\n3. 在终端输入`tsc --init`，我们会多了一个文件`tsconfig.json`\n4. 打开`tsconfig.json`我们可以看到有一个`\"target\": \"es2016\"`	，这里是将TS编译成JS遵循的标准\n5. 终端输入`tsc`，就会将我们的TS转为JS，对应的同名的JS文件\n6. 我们定义变量，可以在变量后使用冒号加一个类型值，就可以申明这个变量的类型了，举个例子：`let name: string = \'xiaoming\'`这里如果给name赋值数值类型，编译的时候就会出错，而不是等到项目上线才会发现这个bug\n7. 我们可以使用`tsc -w`这里的w表示watch，每当文件保存的时候，就会自动的编译此文件为js文件\n8. 我们可以使用断言来解决一些问题，使用断言的方式非常简单，就是在值的末尾使用 as + 类型 即可，举个例子，`let dom = document.querySelector(\'button\') as HTMLButtonElement`这样，我们就强制告诉dom是一个按钮类型的值\n9. 但是，断言的问题是被断言的值是有问题的，所有我们可以使用联合类型，来处理类型为多种情况的场景，使用方式非常简单，使用 | 来连接两个类型，举个例子：`let dom: HTMLButtonElement | null = document.querySelector(\'button\')` \n10. 当我们要给一个对象申明类型的时候，并且这个类型还有很多地方需要复用，我们就可以使用 interface 接口了，使用非常简单，举个例子，`interface item {name: string; age: number; sex: \'boy\' | \'girl\'} `\n11. 我们可以在方法形参括号后加上一个类型，来指定返回类型，举个例子：`function aa(): void {}`\n12. 当我们并不知道Promise返回的具体内容的时候，我们可以用TS的泛型来表示，举个例子：`function getJSON<T>(url: string) {}`，这里的T表示的就是一个占位符，表示现在并不确定里面的类型\n13. 我们在使用 getJSON 方法的时候，可以去确定这个 T 的具体类型\n14. 我们通常定义一个数组类型里面的元素类型，是通过在 [] 前面加上一个具体的类型，例如： `let arr: string[] = [\'1\', \'2\']`,如果数组的元素是对象，那么我们就通过接口（interface）来定义\n15. 我们可以把error类型声明为 unkonwn 或者 Error\n\n```typescript\ntry {}\n	catch (err: Error | unkonwn) {\n    let message: string\n    if(err instanceof Error) {\n      message = err.message\n    }else {\n      message = String(err)\n  }\n    console.log(message, \'message\')\n  }\n```\n\n1. 我们可以在 addEventListener后面加上 <\'click\'>来防止我们在后面监听事件值上出现拼写错误\n2. a 标签的 TS 类型为HTMLAnchorElement\n3. Event事件类型，有鼠标事件和键盘事件的区别\n\n### 小知识\n\n1. 绝大多数游览器识别不了TS，我们需要将TS编译成JS（看过极简Next.js的应该理解），然后给游览器识别运行\n2. tsc表示typescript compiler编译器的意思！init表示初始化\n3. 类型的首字母是小写，不是大写\n4. **使用TS，定义任何东西，要注明类型，调用任何东西要检查类型；**\n5. 类在接收接口（interface）的时候，不能使用变量声明的方式，也就是不能使用冒号（:），我们需要使用 implements 关键字，也就是实现的意思，举个例子：`class Cat implements item {}`\n6. 如果，你的接口里的有些键值对，有可能存在，也有可能不存在，我们可以在键的后面加上 ? 来告诉TS这个值可能不存在，举个例子 `interface item {name: string; age: number; like?: object}`\n\n### 参考\n\n1. 冴羽：https://ts.yayujs.com/\n2. 技术蛋老师：https://www.bilibili.com/video/BV12P411E79E', '2023-06-03 19:32:09', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (31, '初识 Spring Security', '### 前言\n\nSpring Security 是什么呢，在官网里时这样描述的\n\n> Spring Security是一个框架，提供 认证（authentication）、授权（authorization） 和 保护，以抵御常见的攻击。它对保护命令式和响应式应用程序有一流的支持，是保护基于Spring的应用程序的事实标准。\n\n简而言之就是一个安全框架，能够很好的保护我们的 Spring 应用\n\n### Spring Security执行流程（简化）\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1626574509983178753/NDLHc9LJ-image.png)\n（图来自B站：三更草堂）\n从图中可以看到，用户输入的用户名密码会被一路传到 DaoAuthenticationProvider（后文简称 DAP ）， 然后由 InMemoryUserDetailsManager （实现了 UserDetailsService 接口）根据用户名从内存中查找到对应的用户信息并返回给 DAP 。 DAP 将查到的信息与用户输入的信息进行比对，如果正确则返回并存储认证对象（没有json返回值）。\n\n### 整合数据库\n\n上面提到，Spring Security 默认是在内存中查找用户信息，这是不符合我们实际开发的场景的。我们需要从数据库中查到真实的用户信息。\n这时候就需要用到 UserDetailsService 接口，因为最后查找用户的操作是由该接口定义的，我们只需要实现该接口并实现 loadUserByUsername 方法，即可实现从数据库中查找用户信息。\n\n```java\n    @Resource\n    private SysUserService sysUserService;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        SysUser user = sysUserService.getUserByUserName(username);\n        if (user == null) {\n            throw new RuntimeException(\"账号或密码错误\");\n        }\n        LoginUser loginUser = new LoginUser(user);\n        return loginUser;\n    }\n```\n\nloadUserByUsername 方法要求返回的 UserDeatils 对象是 Spring Security 的内置用户对象，我们可以通过组合的方式将查出的用户封装为 UserDeatils 对象。\n\n```java\npackage com.cowz.databasedemo.entity.security;\n\nimport com.cowz.databasedemo.entity.SysUser;\nimport lombok.AllArgsConstructor;\nimport lombok.NoArgsConstructor;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\n\n@NoArgsConstructor\n@AllArgsConstructor\npublic class LoginUser implements UserDetails {\n\n    private SysUser user;\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities() {\n        return null;\n    }\n\n    @Override\n    public String getPassword() {\n        return user.getPassword();\n    }\n\n    @Override\n    public String getUsername() {\n        return user.getUsername();\n    }\n\n    @Override\n    public boolean isAccountNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked() {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired() {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled() {\n        return true;\n    }\n}\n\n```\n\n其中 SysUser 就是我们系统中的用户对象。\n\n### 密码加密器\n\n做完以上操作在进行测试时，会报一个异常\n\n```java\njava.lang.IllegalArgumentException:There is no PasswordEncoder mapped for the id \"null\"\n```\n\n这是由于没有配置密码加密器所引起的，密码加密器确保我们的密码在数据库中是以密文而不是明文存储的。为此我们需要进行以下的配置\n\n```java\n@Configuration\npublic class SpringSecurityConfig {\n\n    @Bean\n    public PasswordEncoder passwordEncoder(){\n        return new BCryptPasswordEncoder();\n    }\n}\n```\n\n', '2023-06-03 19:32:09', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (32, '新人加入', '   一个刚毕业一年的Java后端程序员，分享一下自己工作经历，希望能给大家做为一个参考。\n   毕业时面试上我家这边现在我所在的公司，然后被派往了贵阳作为甲方在外包的公司做一名后端开发，面试时说的会有人带，但是真正进入后组长的态度是当看不见，只有一位老大哥在我有问题时会帮我，但是也只限于当时遇到的问题。项目方面除了那位老大哥会给我讲述一下，其余的组长根本就不理会我，偶尔会让我跟着写写项目，但是一旦有错误或者写的不对了就会让我停下，他自己去写，这一年过的很辛苦，学不到项目上的东西，只能看看B站上的项目视频，自己做一做，要不然只能自己拉代码下来自己研究。也和东家反应过，但是并没有效果。后面技术总监看我实在没事，就让我自己研究爬虫，对app和网站的数据进行爬取，到后面自己将项目布置到服务器上，都靠着的百度、csdn、博客等网站进行学习后将项目完成。我有时也很迷茫，做这些对我未来真的有帮助吗？今年投简历回复的也很少，现在正在学习着鱼老板分享的项目，希望加在简历上之后能够得到更多的回复吧。最后我想说的是遇到这种派去外包公司的公司还是早点离开为好，不然可能会像我一样郁郁寡欢。\n   爬虫方面的经验也会在后面分享给大家。', '2023-06-03 19:32:09', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (33, 'webStorm 激活，支持各版本', '## 2018.2及以后版本：2018、2019、2020、2021、2022、2023均可使用！\n\nBKBY5W58JH-eyJsaWNlbnNlSWQiOiJCS0JZNVc1OEpIIiwibGljZW5zZWVOYW1lIjoiUG9saXRla25payBNZXJsaW1hdSBNZWxha2EiLCJhc3NpZ25lZU5hbWUiOiJ6dW8gemh1IiwiYXNzaWduZWVFbWFpbCI6Inp1b3podTAwMUBjb3N5LmVtYWlsIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJQUyIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTQyIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJTRiIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJEUyIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUEMiLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiIsImV4dGVuZGVkIjpmYWxzZX0seyJjb2RlIjoiUlNWIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IkRDIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2IiwiZXh0ZW5kZWQiOmZhbHNlfSx7ImNvZGUiOiJSU1UiLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYiLCJleHRlbmRlZCI6ZmFsc2V9LHsiY29kZSI6IkRQIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBEQiIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQV1MiLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFNJIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBQUyIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQQ1dNUCIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQR08iLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUFBDIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2IiwiZXh0ZW5kZWQiOnRydWV9LHsiY29kZSI6IlBSQiIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiIsImV4dGVuZGVkIjp0cnVlfSx7ImNvZGUiOiJQU1ciLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYiLCJleHRlbmRlZCI6dHJ1ZX0seyJjb2RlIjoiUlMiLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYiLCJleHRlbmRlZCI6dHJ1ZX1dLCJtZXRhZGF0YSI6IjAxMjAyMjA4MDlMUEFBMDA0MDA4IiwiaGFzaCI6IjM2MTcwMTU0LzE3MzE2NDEwOjE1MDYwMjU1MjciLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-FjJ8+ujI+aKi8rAjizLr93HHm9rU5IW0LxnqATatJhZVObKoU69eUGNUrIsWcEhleNuIolkF+J4B4NruoTneiOHifrWS+oFA7yJMagUfoAN/y9LV9gGD23ALvraZSEyOyUzi1GXTvUNkxL7DZLgt5sonDh265x36o7hWIJLxtDP31fDWV8JFsgyoGY/Q+NmC5qD9uROaBu3aUuUn+pfBIGzmLwQjgkKpBB4K0O+30nNkjwyP+uZxysLcA8OcgnZ4VgpHcKLlRvt9nrOltziPAoZYRuYKOUuz9S7fwg2zmFbE75rq5aQAD2JRjO9F9Wk+oT2OVvlFxGElh9sT43CihQ==-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDCP4uk4SlVdA5nuA3DQC+NsEnZS9npFnO0zrmMWcz1++q2UWJNuGTh0rwi+3fUJIArfvVh7gNtIp93rxjtrQAuf4/Fa6sySp4c32MeFACfC0q+oUoWebhOIaYTYUxm4LAZ355vzt8YeDPmvWKxA81udqEk4gU9NNAOz1Um5/8LyR8SGsSc4EDBRSjcMWMwMkYSauGqGcEUK8WhfplsyF61lKSOFA6VmfUmeDK15rUWWLbOMKgn2cxFA98A+s74T9Oo96CU7rp/umDXvhnyhAXSukw/qCGOVhwKR8B6aeDtoBWQgjnvMtPgOUPRTPkPGbwPwwDkvAHYiuKJ7Bd2wH7rAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBAB2J1ysRudbkqmkUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE/BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5/FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB/R5oUlebwaTE6WZNBs+TA/qPj+5/wi9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329/WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V/0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ/c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0//lOmVya/PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0/WFPl1aw5VV/VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH/0onD\n\n## 2018.1及以前版本：2016、2017均可使用！\n\nBKBY5W58JH-eyJsaWNlbnNlSWQiOiJCS0JZNVc1OEpIIiwibGljZW5zZWVOYW1lIjoiUG9saXRla25payBNZXJsaW1hdSBNZWxha2EiLCJhc3NpZ25lZU5hbWUiOiJ6dW8gemh1IiwiYXNzaWduZWVFbWFpbCI6Inp1b3podTAwMUBjb3N5LmVtYWlsIiwibGljZW5zZVJlc3RyaWN0aW9uIjoiRm9yIGVkdWNhdGlvbmFsIHVzZSBvbmx5IiwiY2hlY2tDb25jdXJyZW50VXNlIjpmYWxzZSwicHJvZHVjdHMiOlt7ImNvZGUiOiJEUE4iLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiJ9LHsiY29kZSI6IlBTIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2In0seyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYifSx7ImNvZGUiOiJSU0MiLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYifSx7ImNvZGUiOiJHTyIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiJ9LHsiY29kZSI6IkRNIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2In0seyJjb2RlIjoiUlNGIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2In0seyJjb2RlIjoiRFMiLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYifSx7ImNvZGUiOiJQQyIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2In0seyJjb2RlIjoiQ0wiLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiJ9LHsiY29kZSI6IlJTViIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiJ9LHsiY29kZSI6IkRDIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2In0seyJjb2RlIjoiRFAiLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYifSx7ImNvZGUiOiJQREIiLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYifSx7ImNvZGUiOiJQV1MiLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYifSx7ImNvZGUiOiJQU0kiLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYifSx7ImNvZGUiOiJQUFMiLCJwYWlkVXBUbyI6IjIwMjMtMDctMjYifSx7ImNvZGUiOiJQQ1dNUCIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiJ9LHsiY29kZSI6IlBHTyIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiJ9LHsiY29kZSI6IlBQQyIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiJ9LHsiY29kZSI6IlBSQiIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiJ9LHsiY29kZSI6IlBTVyIsInBhaWRVcFRvIjoiMjAyMy0wNy0yNiJ9LHsiY29kZSI6IlJTIiwicGFpZFVwVG8iOiIyMDIzLTA3LTI2In1dLCJoYXNoIjoiMzYxNzAxNTQvMTczMTY0MTA6MTUwNjAyNTUyNyIsImdyYWNlUGVyaW9kRGF5cyI6NywiYXV0b1Byb2xvbmdhdGVkIjpmYWxzZSwiaXNBdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlfQ==-JNcWvJ1TDXw4yF4iSVdqu3UaHNS+YfhcOpDgwyMIt5QAsOJ1BtIIT5rvOLCFtLjB9Tm4WDRfF7X33KWGwxOk0y7JXUziurtYkXlbLnMO4+bgLeSlQUDiey3PkPXtUnArcKWJ/TD1F3C25I70gANrspKkEq9M+AvaIGB2gvGX3at6YyOqtU/TpI+ant5qwfzMd9+GIIEUe8sRNf2xZ4DgEyIv11n5Eh7UaX+KZPa6zC2ZWF9wHoBXpLzEZfT+lt1PeQ24TdqmFaZdYqXjii7pdN0pyGzOVTHt20bhOPArSnjD0Dt/DgDqghIISIdMpWIhzYChHfTYl5YbWVFqVUbQ0w==-MIIETDCCAjSgAwIBAgIBDTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTIwMTAxOTA5MDU1M1oXDTIyMTAyMTA5MDU1M1owHzEdMBsGA1UEAwwUcHJvZDJ5LWZyb20tMjAyMDEwMTkwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDCP4uk4SlVdA5nuA3DQC+NsEnZS9npFnO0zrmMWcz1++q2UWJNuGTh0rwi+3fUJIArfvVh7gNtIp93rxjtrQAuf4/Fa6sySp4c32MeFACfC0q+oUoWebhOIaYTYUxm4LAZ355vzt8YeDPmvWKxA81udqEk4gU9NNAOz1Um5/8LyR8SGsSc4EDBRSjcMWMwMkYSauGqGcEUK8WhfplsyF61lKSOFA6VmfUmeDK15rUWWLbOMKgn2cxFA98A+s74T9Oo96CU7rp/umDXvhnyhAXSukw/qCGOVhwKR8B6aeDtoBWQgjnvMtPgOUPRTPkPGbwPwwDkvAHYiuKJ7Bd2wH7rAgMBAAGjgZkwgZYwCQYDVR0TBAIwADAdBgNVHQ4EFgQUJNoRIpb1hUHAk0foMSNM9MCEAv8wSAYDVR0jBEEwP4AUo562SGdCEjZBvW3gubSgUouX8bOhHKQaMBgxFjAUBgNVBAMMDUpldFByb2ZpbGUgQ0GCCQDSbLGDsoN54TATBgNVHSUEDDAKBggrBgEFBQcDATALBgNVHQ8EBAMCBaAwDQYJKoZIhvcNAQELBQADggIBAB2J1ysRudbkqmkUFK8xqhiZaYPd30TlmCmSAaGJ0eBpvkVeqA2jGYhAQRqFiAlFC63JKvWvRZO1iRuWCEfUMkdqQ9VQPXziE/BlsOIgrL6RlJfuFcEZ8TK3syIfIGQZNCxYhLLUuet2HE6LJYPQ5c0jH4kDooRpcVZ4rBxNwddpctUO2te9UU5/FjhioZQsPvd92qOTsV+8Cyl2fvNhNKD1Uu9ff5AkVIQn4JU23ozdB/R5oUlebwaTE6WZNBs+TA/qPj+5/wi9NH71WRB0hqUoLI2AKKyiPw++FtN4Su1vsdDlrAzDj9ILjpjJKA1ImuVcG329/WTYIKysZ1CWK3zATg9BeCUPAV1pQy8ToXOq+RSYen6winZ2OO93eyHv2Iw5kbn1dqfBw1BuTE29V2FJKicJSu8iEOpfoafwJISXmz1wnnWL3V/0NxTulfWsXugOoLfv0ZIBP1xH9kmf22jjQ2JiHhQZP7ZDsreRrOeIQ/c4yR8IQvMLfC0WKQqrHu5ZzXTH4NO3CwGWSlTY74kE91zXB5mwWAx1jig+UXYc2w4RkVhy0//lOmVya/PEepuuTTI4+UJwC7qbVlh5zfhj8oTNUXgN0AOc+Q0/WFPl1aw5VV/VrO8FCoB15lFVlpKaQ1Yh+DVU8ke+rt9Th0BCHXe0uZOEmH0nOnH/0onD\n\n## 可能出现的问题\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/7gtZ6Gir-image.png)\n', '2023-06-03 19:32:09', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (34, '自我介绍', '大家好,我是一名Java软件工程师。coding是我的专业,篮球是我的兴趣。\n在工作中,我热衷于编写高质量的代码,构建稳定、高效的软件系统。我擅长Java语言和相关技术栈,如SpringBoot、MySQL、Redis等,并且具备分布式系统设计和开发经验。我热爱敏捷开发,追求简洁实用的代码和架构。\n在生活中,我的最大爱好就是打篮球。我每周固定与朋友们在室内外篮球场约上几场,运动是我解压的最佳方式。篮球也教会我很多,如团队合作、目标实现等。每当工作遇到瓶颈时,我会去打会篮球,运动过后总能心情愉悦、问题迎刃而解。', '2023-06-03 19:32:10', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (35, '简单的介绍下前端菜鸡旺仔！', '# 我的背景\n2016 年毕业于北京 211 某大学，金融本科，2018 年毕业于美国 US Top50，金融分析硕士，回国后一直在全职炒股，想做量化交易，自学 python 还有数据分析相关的包 pandas、matplotlib、seaborn、自动化excel、sklearn 、爬虫等等，学完发现编程不实践学再多就是白瞎，所以试着去找了工作，靠着这些背景，很幸运，我自己找到一家信贷公司工作，工作至今。\n\n# 人生转折-前端\n这几年股票行情不好，亏的差不多了，在工作中又发现要想研究量化交易更多的不是看你代码能力，而是数学（统计）功底，果断放弃了量化交易这条路，幸好在工作中，做模型的时候需要做可视化，接触到了前端，发现前端其实很适合我这种性格，所见即所得，正反馈很强，正好也想做个关于宠物的小程序创业，便开始了我的前端学习之路。\n\n# 前端学习情况\n我其实一直不想当培训班的韭菜，当时自学 python 都没什么问题，也就想自学前端，主要靠 B 站的视频和自己买书看，目前学完了三剑客，vue2全家桶、vue3全家桶、uniapp、微信小程序、webpack、vite、sass、ts、各种组件库element-ui、vuetify等，目前在跟着 B 站敲项目，也会去学下网络基础原理，tcp,https协议等。\n\n# 为什么要加入鱼皮这个大家庭？\n1. 因为自己在自学的过程中，都是看一些培训班的课程，他们录制的视频知识点几乎不能是全面的，而且时效性也不高，有些技术都很老了，所以看了他们的视频是远远不够的，不利于我技术的进步。\n2. 看B站的视频真的很浪费时间，因为担心跳着视频看会略过一些知识点，所以只能一点点看，很累。\n3. 我的实战经验太弱了。加入这个大家庭，希望可以和各位大佬们多学习，也想着能跟着鱼皮大哥多学习学习实战，毕竟非科班转行不易。\n4. 自己认为目前自己前端技术栈不够全面和完整，肯定有自己没有涉及的地方，比如设计模式架构等等，希望可以和真正的程序员们学习。\n\n# 我的目标\n希望能自己完成从0-1的小程序上线（前后端），完成自己的宠物创业项目，同时能学一些计算机视觉相关的内容，毕竟我这机器学习不能白学，哈哈。\n\n最后，很高兴能认识大家，希望能和大家一起共同进步！完成自己的梦想！加油兄弟们！\n抖音：**旺仔五万块创业**\n------用于记录我自己学习的过程\n', '2023-06-03 19:32:10', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (36, '炸裂的 AutoGPT，鱼皮教你免费用！', '大家好，我是鱼皮，继前段时间爆火的 ChatGPT 后，又一个炸裂的开源项目 `Auto-GPT` 出现了。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423130304295.png)\n\n仅在最近 10 天，这个项目就收获了 8 万多个 star，目前总 star 数超过 10 万！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423130209755.png)\n\n那 Auto-GPT 到底是个什么玩意？它到底凭什么这么火？如何使用和部署它？它到底真的实用么？\n\n带着这些问题来看这篇文章，下面我就给大家分享下 Auto-GPT 的介绍、最简单的部署方法、并且做一个简单的上手体验。\n\n> 本文对应视频教程：https://www.bilibili.com/video/BV1ho4y1b75o/\n\n\n\n### 什么是 Auto-GPT？\n\nAuto 即自动，Auto-GPT 就表示自动的 GPT。\n\n什么意思呢？\n\n以前假如我们想使用 ChatGPT 来写一篇论文，可能要 **人工** 问它好几个问题，比如：\n\n问：我想写一篇关于 AI 的论文，我需要怎么做？\n\nAI 答：确认选题、写背景、写程序、写实验、写总结等。\n\n问：帮我想 1 个选题\n\nAI 答：AutoGPT\n\n问：帮我介绍下 AutoGPT 的背景\n\n。。。\n\n你需要多次人工地向 AI 提问，直到你最后完成一篇论文。\n\n但有了 AutoGPT，你只需要告诉它一个目标，比如 “写一篇关于 AI 的论文”，它就能够用程序全自动地完成目标。\n\n当然，和人类一样，它也不是一步到位的，而是先自动向 AI 提问，然后根据 AI 的回答再自动提出新的问题，如此循环往复直到达成你告诉它的目标。\n\n> AutoGPT 本身也是结合了 LLM 大语言模型，相当于让 AI 来指挥 AI。\n\n此外，AutoGPT 还有个很 🐂 的能力，当它发现 GPT 无法回答他的问题时，会主动到网上搜索答案，这样就弥补了 GPT 训练数据只到 21 年 9 月的不足。\n\n![官方介绍的特性](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423131622842.png)\n\n听上去感觉很厉害，那接下来我们就来整一个自己的 Auto-GPT 吧~\n\n\n\n### 搭一个自己的 Auto-GPT\n\n网上很多教程都是让大家在自己本地搭建 Auto-GPT，其实是不推荐的，不仅麻烦，而且可能存在环境、依赖不一致的情况。\n\n个人认为最简单的方式是使用 `GitPod` 云托管服务，直接用别人提供的服务器来部署 Auto-GPT，用来学习再好不过了。\n\n首先访问官方仓库：https://github.com/Significant-Gravitas/Auto-GPT\n\n然后点击 Fork，复制仓库到自己的 GitHub 中：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423132110893.png)\n\n这一步千万要注意！取消勾选 `Copy the master branch only` ！因为 `master` 分支的代码可能是不稳定的（我就翻过车）！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423132346281-20230423132737947.png)\n\nFork 成功之后，我们进入到自己的仓库中，然后把浏览器地址中的 `github.com` 改为 `gitpod.io/#` 。\n\n比如我的是地址： `https://github.com/liyupi/Auto-GPT `，改成 `https://gitpod.io/#/liyupi/Auto-GPT` ，然后访问，现在就可以一键用 GitPod 来部署项目了！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423132605882.png)\n\n然后我们就进入到了 GitPod 项目主页，大家现在就可以把这个网页当做自己的电脑（服务器）来使用了，比如使用 VS Code 编辑器。\n\n进到这个页面后，第一件事是切换分支，一定要选择 `origin/stable` 分支！否则后面说不定遇到什么奇奇怪怪的 Bug。\n\n如下图：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423132829674.png)\n\n然后，我们在左侧目录中找到 `.env.template` 文件，右键修改文件名为 `.env` ，并且修改 OPEN_API_KEY 为自己的。\n\n> 因为 Auto-GPT 底层也是向 OpenAI 提问的，所以必须要有 OpenAI 的 key。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423133223230.png)\n\n修改完成后，在终端中输入 `./run.sh` 命令，就会自动安装所需环境和依赖，等着就好~\n\n看到下图中的消息，就表示安装成功了！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423134311912.png)\n\n然后我们按 `ctrl + c` 退出程序，以后不要用 `run.sh` 命令启动了，因为每次都要检查依赖，我们可以直接用 `python -m autogpt` 命令来启动 autogpt。\n\n比如执行 `python -m autogpt --help` ，查看 autogpt 的用法和参数说明： \n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423134614047.png)\n\n上图中，有几个参数是需要额外关注的，比如：\n\n- -c：是否开启连续模式。这是一个非常危险的命令！表示 autogpt 会不经过你的同意全自动执行，包括但不限于死循环、无限创建文件、占满空间后删除你电脑上的文件等等。就和人类一样：可能会为了达到目的不择手段！\n- -l：指定连续执行的次数限制。可以防止死循环。\n- --speak：开启语音模式。但不是说在浏览器内部播放声音，而是生成音频文件。\n\nOK，了解了这些后，我们来体验一下~\n\n\n\n### 牛刀小试\n\n就给一个很简单的任务吧，让 autogpt 帮忙 “写一个网站，赞美一只鸡在打篮球”。\n\n首先执行 `python -m autogpt` 命令，然后依次输入 AI 名称、AI 角色和目标：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423135414380.png)\n\n然后 autogpt 就屁颠儿屁颠儿去工作了，我们可以看到他的想法、计划和下面要做的行动。比如他打算到网上搜索更多信息，使用 Google 搜索命令。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423135450228.png)\n\n我们可以输入 `y` 表示同意他这么做，也可以输入任何内容和建议来影响他的操作。\n\n这里我就同意他吧~\n\n然后呢，这货竟然说要看网上的视频来学习！好家伙，AI 也要摸鱼？\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423135754861.png)\n\n同意之后，他直接就下载视频文件了，结果没想到因为我的服务器上没有浏览器，他看不了视频！只能再倒回去 Google 搜索。\n\n那我们再输入 `y` 表示同意：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423140026739.png)\n\n结果你猜怎么着，他又想去看视频！已经陷入循环了。。。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423140059101.png)\n\n所以可想而知，如果你让 autogpt 全自动跑一天，除了你的 OpenAI Key 余额被消耗完之外，说不定没有任何的成果。\n\n所以人类必须要出手了，我让它：不要再看视频了，任何文本都行！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423140425183.png)\n\n结果呢。。。它表示要去浏览其他的网页，不听话啊！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423140251942.png)\n\n所以我态度只能再强硬一点！“停止调研，立刻给我开发网站！”\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423140555673.png)\n\n这次他听话了，而且计划执行 `write_to_file` 命令生成了网站：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423140529400.png)\n\n输入 `y` 表示允许，然后他就帮我们在工作空间下生成了 `index.html` 文件：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423140758809.png)\n\n网站生成完毕！让我们本地打开验证一下，看到了如下的文字 “鸡不仅能用来吃，他们也会打篮球”。并且分享了一篇文章和一个视频！\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423140912174.png)\n\n视频来源于 youtube，点开视频，我笑疯了：\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423141103354.png)\n\n虽然有点投鸡取巧，但不管怎么样，autogpt 也算是在短时间内完成了一个网站吧，还是很不错的！\n\n不过完成这个网站后，autogpt 并没有停止的意思，依然执着地在 youtube 搜索鸡打篮球相关的视频。\n\n![](https://yupi-picture-1256524210.cos.ap-shanghai.myqcloud.com/1/image-20230423141254699.png)\n\n所以朋友们，连续模式是真的危险，AI 如果脱离了人的控制，也是真的危险啊！\n\n> 我的编程导航网站：[https://www.code-nav.cn](https://www.code-nav.cn)', '2023-06-03 19:32:10', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (37, '前端 JavaScript 与 HTML 怎么实现交互', '前端 JavaScript 和 HTML 可以通过事件监听器、DOM 操作、Ajax、表单交互、动态创建和修改 HTML 元素等方式实现交互；具体的实现方式如下：\n\n# 1、事件监听器\n\nJavaScript 可以在 HTML 元素上设置事件监听器，以便在特定事件（例如单击、鼠标悬停或键盘敲击）发生时触发 JavaScript 代码。\n\n例如，以下代码段演示了如何在 HTML 元素上设置单击事件监听器：\n\n```js\n<button onclick=\"myFunction()\">Click me</button>\n\n<script>\nfunction myFunction() {\n alert(\"Hello World!\");\n}\n</script>\n```\n\n# 2、DOM 操作\n\nJavaScript 可以使用 Document Object Model (DOM) 操作 HTML 元素。DOM 是一种表示 HTML 页面的树形结构，可以使用 JavaScript 修改 HTML 元素的内容、属性和样式。\n\n例如，以下代码段演示了如何使用 JavaScript 获取 HTML 元素的值并将其更改为新值：\n\n```js\n<p id=\"demo\">Hello World!</p>\n\n<script>\nvar x = document.getElementById(\"demo\");\nx.innerHTML = \"Hello JavaScript!\";\n</script>\n```\n\n# 3、Ajax\n\nAjax 是一种使用 JavaScript 发送和接收数据的技术。它可以使 Web 应用程序与服务器进行交互，而无需刷新整个页面。\n\n例如，以下代码段演示了如何使用 Ajax 发送 GET 请求并在 HTML 页面上显示响应数据：\n\n```js\n<button onclick=\"loadDoc()\">Click me</button>\n\n<script>\nfunction loadDoc() {\n var xhttp = new XMLHttpRequest();\n xhttp.onreadystatechange = function() {\n   if (this.readyState == 4 && this.status == 200) {\n     document.getElementById(\"demo\").innerHTML = this.responseText;\n  }\n};\n xhttp.open(\"GET\", \"ajax_info.txt\", true);\n xhttp.send();\n}\n</script>\n```\n\n# 4、表单交互：\n\nHTML 中的表单元素（例如输入框、下拉列表、复选框等）可以与 JavaScript 进行交互。JavaScript 可以在表单元素上设置事件监听器，并读取或修改表单元素的值。\n\n例如，以下代码段演示了如何使用 JavaScript 获取表单元素的值：\n\n```js\n<form>\n <label for=\"name\">Name:</label>\n <input type=\"text\" id=\"name\" name=\"name\"><br><br>\n <button type=\"button\" onclick=\"myFunction()\">Submit</button>\n</form>\n\n<script>\nfunction myFunction() {\n var name = document.getElementById(\"name\").value;\n alert(\"Hello \" + name + \"!\");\n}\n</script>\n```\n\n# 5、动态创建和修改 HTML 元素：\n\nJavaScript 可以动态创建和修改 HTML 元素，从而实现动态页面效果。例如，JavaScript 可以在页面上添加新元素、更改元素的样式、更改元素的内容等等。\n\n例如，以下代码段演示了如何使用 JavaScript 动态创建一个新的段落元素，并将其添加到页面中：\n\n```js\n<button onclick=\"myFunction()\">Add Paragraph</button>\n\n<script>\nfunction myFunction() {\n var para = document.createElement(\"p\");\n var node = document.createTextNode(\"This is a new paragraph.\");\n para.appendChild(node);\n\n var element = document.getElementById(\"div1\");\n element.appendChild(para);\n}\n</script>\n```\n\n以上是 JavaScript 和 HTML 实现交互的一些常见方式。通过使用这些技术，开发人员可以创建动态、交互式的 Web 应用程序。', '2023-06-03 19:32:10', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (38, '初原挽风的自我介绍', '## 简述自己\n姓名：初原挽风  \n学历：本科二本院校（目前大一）  \n经历：早期对计算机特别感兴趣，了解了许许多多相关的知识，也学习过 python 语言，并且经历过大一上的学习，越来越对编程感兴趣，希望在这里可以提高编程能力 增加编程的兴趣 同时也希望结交一些有着同样目标的朋友\n\n## 短期实现目标\n1. 学好 Java \n2. 自我 Git 相关知识\n3. 学习计算机网络\n4. 学习前端三件套  \n\n## 长期实现目标\n* 全栈工程师', '2023-06-03 19:32:10', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (39, '前端如何让用户写自定义代码，深入配置', '前段时间在用Angular开发动态表格，类似于低代码配置表格属性，做到表单验证时，用户只能配置一些常规的表单验证，或者通过正则判断，但是如果需要表单内一些复杂逻辑，比如input 1 + input2 满足某些特定条件，那么该如何去做呢？\n\n## 解决方法\n在ngx-formly的fields中用到了如下代码：\n\n```ts\nexpressions: {\n  \'props.label\': `model.roleId === \'<new_role>\' ? \'Add New Role\' : \'Role Details\'`\n}\n```\n\n大致就是通过某个特定条件来渲染当前表单项的label，当时好奇为什么都是用字符串，而不是直接用js，还能有高亮提示，后面去阅读到了formly与expressions相关源码，发现原来是通过[eval](https://github.com/ngx-formly/ngx-formly/blob/HEAD/src/core/src/lib/extensions/field-expression/utils.ts)来执行的，又学习到了。\n\n## 源码如下：\n```ts\nexport function evalStringExpression(expression: string, argNames: string[]) {\n  try {\n    return Function(...argNames, `return ${expression};`) as any;\n  } catch (error) {\n    console.error(error);\n  }\n}\nexport function evalExpression(expression: string | Function | boolean, thisArg: any, argVal: any[]): any {\n  if (typeof expression === \'function\') {\n    return expression.apply(thisArg, argVal);\n  } else {\n    return expression ? true : false;\n  }\n}\n```\n\n\n## 具体用法\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1621094259987947521/Iqyk7SJ1-image.png)\n\n通过点击button，然后就执行用户输入的eval内容：**弹窗 + 输出当前text的表单项内容 + 换行 + 自定义内容** \n```ts\nconst [form] = useForm()\nconst handlerClick = () => {\n        evalExpression(\n           evalStringExpression(form.getFieldValue(\'eval\'), [\'form\']),\n           this,\n           [form])\n}\n```\n\n\n这么写的好处\n\n通过evalExpression可以获取**当前环境**的一个上下文，传递给用户使用，也就是说我可以把想要的环境提供给用户操作使用，上面例子就是把当前的form对象给了用户，那么用户就可以直接使用 form 来获取当前所有表单项的操作，那么我就可以做复杂的表单逻辑验证，包括直接写正则等；把这一块逻辑提供给了用户使用。\n\n通过昨天的股东大会，受到鱼皮的激励，就应该多分享一些东西，锻炼一下文笔，最关键是如果我能把这个东西说清楚了，那么证明我也是真的学废了这个知识点！！！\n\n欢迎各位友友们，批评指正~', '2023-06-03 19:32:10', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (40, 'java list、set、map都是什么？', 'Java中的List、Set和Map都是集合类，用于在Java程序中存储和操作数据。\n\nList是一个有序的集合，允许重复元素。它可以通过索引来访问集合中的元素，也可以按照特定的条件进行搜索和排序。常用的List实现类包括ArrayList、LinkedList和Vector等。\n\nSet是一个不允许重复元素的集合。它提供了添加、删除、搜索等操作，并且可以将两个Set集合进行交集、并集、差集等操作。常用的Set实现类包括HashSet、TreeSet和LinkedHashSet等。\n\nMap是一个映射表，它存储key-value键值对。Map的实现类包括HashMap、LinkedHashMap、TreeMap等。Map的常用方法包括put()和get()方法，可以通过Key来获取相应的Value值。\n\n这些集合类都是Java集合框架的一部分，通过使用它们可以方便地存储和操作数据。', '2023-06-03 19:32:10', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (41, 'MySQL的B+ 树与B-树', 'MySQL使用B+树和B-树作为索引结构来加速数据库操作。这两种树都是多路搜索树，主要的区别在于它们在节点中存储的数据项的数量不同。\n\nB+树是以平衡树为基础的一种多路搜索树。在B+树中，所有的关键字都出现在叶子节点的链表中（因此也称为关键字稠密索引），即每个节点中存储的是key-value键值对，但非叶子节点只起到索引作用，不存储数据。这种设计可以使得B+树在查找、插入、删除操作中都更加高效。因此，B+树主要用于支持范围查询。\n\nB-树也是一种多路平衡树结构，与B+树的最大区别在于B-树的非叶子节点会存储数据项（键值对），而不仅仅是索引信息。这样可以减少树的高度，从而提高查询效率。B-树主要用于磁盘或其他外部存储系统的文件系统。\n\n总之，两者都是面向磁盘存储的索引结构，由于I/O操作成为瓶颈，它们的重点都放在了尽量减少I/O操作次数上。具体情况下，需要根据实际的业务需求和数据结构特征来选择使用哪种树。', '2023-06-03 19:32:10', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (42, 'coderwhy的vue3课程笔记- 组合式 API 2', '#### 认识h函数\n\nVue绝大多数情况使用模板来创建HTML，但是有些地方需要`JavaScript`的编辑能力，我们可以使用渲染函数，它比模板更接近编译器\n\n##### VNode和VDOM\n\n- vue在生成真实DOM之前，会将我们的节点转成VNode，而VNode组合在一起形成一颗树结构，就是虚拟DOM(VDOM)\n- 事实上，我们之前编写的template中的HTML最终也是使用渲染函数生成对应的VNode\n- 那么，如果想要使用JavaScript来生成相应的VNode，我们可以自己来编写creatVNode函数实现\n- 我们可以使用`h()`函数：一个用于创建vnode的函数；其实更准确的命名是createVNode()函数，所有h()又是语法糖啦！！！ \n\n##### h()函数使用方法\n\n它接收三个参数：\n\n1. `type:`\n\n1. 1. 类型：string | object | function\n   2. 详细：HTML标签名，组件，异步组件，函数式组件。使用返回 null 的函数将渲染一个注释。此参数是必需的。\n\n1. `props:`\n\n1. 1. 类型：object\n   2. 详细：一个对象，与我们将在模板中使用的 attribute、prop 和事件相对应。可选。\n\n1. `children:`\n\n1. 1. 类型：string | Array | Object\n   2. 详细：子代 VNode，使用 h() 生成，或者使用字符串来获取“文本 VNode”，或带有插槽的对象。可选。\n\n```javascript\nh(\'div\', {}, [\n  \'Some text comes first.\',\n  h(\'h1\', \'A headline\'),\n  h(MyComponent, {\n    someProp: \'foobar\'\n  })\n])\n```\n\n##### 注意：\n\n如果没有props，（第二个参数）那么通常可以将children作为第二个参数，如果会产生歧义，那么就可以将null作为第二个参数，将children作为第三个参数\n\n#### vue中使用JSX\n\n###### 使用配置\n\n如果想要在vue项目中使用jsx，我们需要添加对jsx的支持，我们可以用Babel来进行转换，我们需要在Babel中配置对应的插件，\n\n- 安装Babel支持vue的jsx插件\n\n```bash\nnpm install @vue/babel-plugin-jsx -D\n```\n\n- 在babel.config.js配置文件中配置插件\n\n```javascript\nmodule.exports = {\n  presets: [\n    \'@vue/cli-plugin-babel/preset\'\n  ],\n  plugins: [\n    \"vue/babel-plugin-jsx\"\n  ]\n}\n```\n\n#### 自定义指令\n\nvue允许我们自己来定义一些自定义指令\n\n##### 使用场景\n\n- 在Vue中，代码的复用和抽象主要还是通过组件\n- 通常，当你需要对DOM元素进行底层操作时候，我们需要用到自定义指令\n\n##### 使用方式\n\n- 自定义局部指令：组件中通过`directives`选项，只能在当前组件中使用\n- 自定义全局指令：app的`directive`方法。可以在任意组件中使用\n\n```javascript\n// 局部指令\n directives: {\n      focus: {\n        mounted(el, bindings, vnode, preVnode) {\n          console.log(bindings, vnode, preVnode, \"focus mounted\");\n          el.focus();\n        }\n      }\n    }\n// 全局指令\napp.directive(\"focus\", {\n  mounted(el, bindings, vnode, preVnode) {\n    console.log(\"focus mounted\");\n    el.focus();\n  }\n})\n```\n\n**一个指令定义的对象，Vue提供了如下的几个钩子函数：**\n\n- created:在绑定元素的attribute或事件监听器被应用之前调用；\n- beforeMount:当指令第一次绑定到元素并且在挂载父组件之前调用；\n- mounted:在绑定元素的父组件被挂载后调用；\n- beforeUpdate:在更新包含组件的VNode之前调用；\n- updated:在包含组件的VNode及其子组件的VNode更新后调用；\n- beforeUnmount:在卸载绑定元素的父组件之前调用；\n- unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次；\n\n#### 自定义指令的参数和修饰符\n\n```html\n<button v-if=\"counter < 2\" v-why:info.aaaa-bbbb=\"\'coderwhy\'\" >当前计数: {{counter}}</button>\n```\n\n- info是参数名称\n- aaa-bbb是修饰符的名称\n- 后面传入具体的值\n- 在生命周期中，我们可以通过bingings获取到对应的内容\n\n#### 认识Teleport\n\n##### 为了解决？\n\n在组件开发中，我们封装一个组件A，在另一个组件B中使用，组件A中template的元素，会被挂载到组件B中template的某个位置，但是某些情况下，我们希望组件不是挂载在这个组件树上的，可能是移动到Vue app之外的其他位置，例如移动到body元素上\n\n##### 是什么？\n\n他是一个Vue提供的内置组件，类似React的Portals\n\n它有两个属性：\n\n- to：指定将其内容移动到的目标元素，可以使用选择器；\n- disabled：是否禁用teleport的功能；\n\n\n\n#### getCurrentInstance\n\n用户获取全局属性(在setup中没有this) 官方说的是 ： 支持访问内部组件实例\n\n```vue\n<script>\n  import { getCurrentInstance } from \"vue\";\n\n  export default {\n    setup() {\n      const instance = getCurrentInstance();\n      console.log(instance.appContext.config.globalProperties.$name);\n    },\n    mounted() {\n      console.log(this.$name);\n    },\n    methods: {\n      foo() {\n        console.log(this.$name);\n      }\n    }\n  }\n</script>\n```\n\n#### Vue插件\n\n通常我们向Vue全局添加一些功能，会采用插件的模式，写法有两种：\n\n- 对象类型：一个对象，但是必须包含一个install函数，该函数会在安装插件时执行，\n- 函数类型：一个function，这个函数会在安装插件时自动执行，\n\n插件功能没有限制，比如一下几种都可以：\n\n- 添加全局方法或者property，通过把他们添加到`config.globalProperties`上实现；\n- 添加全局资源：指令，过滤器，过渡等；\n- 通过全局mixin来添加一些组件选项；\n- 一个库，提供自己的API，同时提供上面提到的一个或多个功能\n\n\n![1651832138475-4046a344-c3f0-4e49-9ec2-d04f2a064025.png](https://pic.code-nav.cn/post_picture/1619930914211520514/9JnZaGxx-1651832138475-4046a344-c3f0-4e49-9ec2-d04f2a064025.png)', '2023-06-03 19:32:10', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (43, '解决 bug 的经验', '## 如何快乐高效的解决 bug\n\n​	五一，当然要劳动啦！大家五一节日快乐！\n\n​	刚学习编程那会，我也和很多小伙伴一样，害怕红色的bug，现在，我会和乐意去解决遇到的每一个 bug、因为我知道解决了它，我会变的更厉害\n\n​	程序员，也就是使用一门语言编写可靠的代码去解决实际的需求，但是即使是世界上最优秀的程序员，也不能保证他写的代码没有任何问题。那么，一个优秀的程序员，应该是同时拥有**编写出良好的代码的能力**和**解决bug的能力**，而且解决 bug 的能力更加重要，因为写代码是在自己熟悉的领域输出，解决 bug 是学习新的知识，跳出舒适圈\n\n​	首先作为一个程序员，只要是写代码，肯定是会产生 bug，除非这个人不写代码，所以每个程序员需心平气和的接受。要是有个人说自己写代码没有出现过bug，那这个人肯定是骗你的或者这个人很自大。但并不代表你产生的 bug 越多你就越牛，我们在编程的时候，肯定是要采取各种手段避免 bug 的发生。例如：前端的 Typescript，它就是为了减少 bug 。\n\n​	接下来，我来讲一下，我个人在解决无数 bug 后的一点经验，\n\n#### 心态要好\n\n> 放在最前面，是我认为这是最重要的事情\n\n**在修复bug过程中，最重要的一个心态就是切莫急躁，急躁是修复不了bug的。** 面对bug要有以下的心态转变：\n\n1. **保持耐心和冷静**：慌张和急躁可能导致错误的决策和低效的解决方案。从容地分析问题，遵循解决bug的方法一步一步地解决，\n2. **积极主动地寻求帮助**：如果遇到难以解决的问题，不要犹豫向团队成员、社区或互联网寻求帮助。同事和社区成员可能会提供有价值的建议和指导。同时，这种互助和分享的过程有助于团队成长和知识传递。\n3. **看待Bug作为学习和成长的机会**：将Bug视为学习新技能、深入了解系统和提高解决问题能力的机会。从中吸取教训，提高自己的技能和经验。如果你解决 bug 后，回想，你会发现你成长了，学到了新的知识，\n4. 保持乐观，自信，相信自己能解决这个问题\n5. 面对复杂的bug，适时地的休息和调整\n6. 最后一定要 🎉 ，自己成功解决了 bug\n\n#### 解决bug的思路，方法\n\n> 往往一个 bug ，是因为我们的粗心，或者对业务的不理解导致的\n\n1. **复现 bug**：确保Bug不是由于理解错误或设计改动导致的。\n2. **收集 bug 相关信息**；这包括：\n   1. Bug出现的频率和条件\n   2. Bug的影响范围\n   3. 报告Bug的用户或同事提供的信息\n   4. 测试环境、开发环境或生产环境中的错误日志\n   5. 浏览器控制台中的错误信息（针对前端Bug）\n3. **缩小问题范围**：通过分析收集到的信息，缩小问题所在的范围。以下是一些建议：\n   1. 将复杂问题拆分为更小、更简单的部分\n   2. 使用二分法逐步缩小问题范围\n   3. 确定问题发生在哪个模块或组件中\n   4. 确定问题是由前端还是后端引起的\n   5. 确定问题与特定浏览器、操作系统或设备有关还是普遍存在\n4. **问题定位**：找到问题的根源。在这个阶段，需要：\n   1. 阅读相关代码，了解逻辑\n   2. 使用调试工具（如浏览器的开发者工具或IDE中的**断点**调试功能）进行逐步调试，最常见的就是我们的 **Debug**\n   3. 观察变量值和执行流程，了解它们与预期的差异\n   4. 对后端代码，可以使用日志记录或断点调试来监控关键变量和执行路径\n   5. 对前端代码，可以使用浏览器的开发者工具进行实时调试，查看HTML、CSS和JavaScript中的问题\n5. **设计解决方案**：（对于复杂问题）在设计解决方案时，要考虑以下因素：\n   1. 解决方案是否有效地解决了问题\n   2. 解决方案是否会引入新的Bug或问题\n   3. 解决方案是否符合代码规范和设计原则\n   4. 解决方案的性能影响\n   5. 解决方案的可维护性和可扩展性\n6. **执行方案**：\n   1. 编写可读、简洁和高效的代码\n   2. 遵循团队约定和编码风格\n   3. 对修改过的代码片段进行注释，解释更改的原因和实现方法\n7. **测试**：\n   1. 重新尝试重现Bug，确保问题已解决\n   2. 对修改过的功能或模块进行详尽测试\n   3. 对相关功能进行回归测试，确保更改没有产生副作用\n   4. 在不同浏览器、操作系统和设备上进行兼容性测试（针对前端开发）\n8. **代码 review，确保没有引入新的问题**：\n   1. 向同事解释Bug的根本原因以及解决方案的设计\n   2. 讨论解决方案的优缺点，以及可能的改进方法\n   3. 根据团队成员的反馈进行调整和优化\n9. **整理文档**：解决Bug的过程中可能会发现一些值得记录和分享的经验。请务必撰写文档，将这些经验分享给团队成员，以便今后遇到类似问题时能够迅速解决。同时，从中汲取教训，改进开发和测试流程，以减少类似Bug的出现。\n10. **持续改进，以小见大**，在解决Bug后，要反思整个过程，思考如何改进开发流程、测试策略和团队协作。这有助于降低未来Bug的产生，提高软件质量，为用户提供更好的体验。\n\n#### 如何减少 bug\n\n> 无论怎么说，bug 都是不好的，也都是由于我们导致产生的，那么减少 bug 的产生，是不是也很重要呢？我总结了一些减少写出 bug 代码的方法，其实一句话说就是写代码前要先做准备\n\n1. **计划和设计**：在编写代码之前，充分了解需求、功能和目标。合理地规划和设计程序结构，以便创建可维护、可扩展和稳定的代码。很多 bug 其实都是对业务的不熟悉导致的，\n2. **遵循编码规范和风格指南**：遵循团队和行业的编码规范和风格指南，以确保代码具有一致性和可读性。这有助于减少因不一致和混乱而导致的Bug。例如：前端的 Eslint + prettier，极大的提高代码的可读性\n3. **写简洁，模块化的代码**：编写简洁、易于理解的代码。将代码拆分为独立、可重用的模块或组件，以降低复杂性和出错的可能性。\n4. **使用版本控制**，使用版本控制系统（如Git），以便跟踪代码更改、回滚错误的提交以及更容易地协作。通过代码审查，确保Bug在合并到主分支之前被发现和修复。\n\n5. **注释和文档**：为关键部分和复杂逻辑编写注释，以便其他开发者（以及您自己）能够更容易地理解和维护代码。同时，撰写详细的文档，说明程序的功能、架构和使用方法。\n6. **单元测试和自动化测试**：编写单元测试以检查代码的正确性和稳定性。通过自动化测试框架，确保在每次更改后运行测试，以便快速发现和修复Bug。同时，考虑编写集成测试、端到端测试和回归测试以确保整个系统的稳定性。\n7. **代码审查**：定期的代码审查，以便发现潜在问题并在早期阶段进行修复。这有助于提高代码质量，分享知识并保持团队间的一致性。\n8. **重构**：定期对代码进行重构，以改进其结构、提高可读性和性能。重构有助于消除潜在的Bug并减少新Bug的产生。\n9. **学习和使用设计模式**：了解和应用设计模式。设计模式是在特定情况下解决特定问题的经过验证的解决方案。它们可以帮助您编写更可维护、可扩展和稳定的代码，从而减少Bug的发生\n10. **持续学习提高自己的技术能力，学习新技术，最佳实践和编程原理，阅读优秀，经典书籍，学习计算机基础知识**\n\n最后，希望大家都能写出优秀的代码，做出自己满意的产品，通过 code ，让世界变得更好！', '2023-06-03 19:32:10', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (44, 'MySQL的SQL语句性能优化', 'MySQL的SQL语句性能优化可以通过以下几个方面来实现：\n\n1. 合理设计表结构：表的设计需要根据数据的特点和实际需要进行优化。比如，使用合适的数据类型、避免使用过多的关联表、遵循数据库范式等。\n\n2. 优化查询语句：对于查询语句，应该尽量避免使用SELECT *，而是指定需要的字段，以减小数据传输的量。同时，使用合适的WHERE条件、建立索引等能有效提高查询效率，减少不必要的数据扫描。\n\n3. 优化表结构和查询语句的性能都离不开MySQL的索引机制。索引的建立需要考虑字段的选择、类型和长度等因素，以及在使用索引的同时也要考虑索引的维护和更新的开销。\n\n4. 避免大量的重复操作。在编写SQL语句时，应该考虑到需要执行的操作数，避免在循环或递归语句中进行大量的重复操作。\n\n5. 应用缓存：尽可能地使用缓存技术，如将常用的查询结果缓存到Redis等内存型数据库中，从而无需每次都执行SQL查询语句。\n\n最后，为了保证数据库的高可用性和高安全性，还需要对数据库进行备份和恢复、监控和日志记录等操作，以及定期进行数据库维护、优化和升级等工作。', '2023-06-03 19:32:10', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (45, '阶段总结', '加入星球`9个月`啦, 总结一下!!!\n\n时间 : 从2022年7月到2023年5月 \n\n目前现状 : 大一\n1. 按照鱼皮的路线学到了 `pring5`框架\n2. 算法还没开始刷 LeetCode刷题目为 0\n3. 计算机的一些理论不清楚(专科学校不讲)\n4. 英语水平比较烂, 正在背单词中\n\n### 关键的时间节点\n\n1. `Java基础`的学习, 花费大概5个月. 时间花费的不少, 但是我感觉还挺值得的, 毕竟基础很重要. 【更多的原因是前期找资源, 摸索学习模式花了不少时间】. 看过 韩顺平的Java基础 和 尚硅谷的Java基础\n\n![Snipaste_2023-05-21_16-17-09.png](https://pic.code-nav.cn/post_picture/1608460212774109186/DVTaH6Z4-Snipaste_2023-05-21_16-17-09.png)\n\n2. `JavaWeb`学习 大概花费大概5个月. 正常的学习,记录笔记【感觉自己的笔记有点水没发出来】. 对于我来说JavaWeb真的上升了一个难度等级, 有一些bug和Java基础的bug简直不是一个难度的. 就像韩顺平说的:\"Java基础是全部的都是自己写的, 但是到了JavaWeb自己写的东西占比就减少了, 像浏览器和Tomcat都不是自己写的, 学习难度变大\". 但是只要自己认真学习一定可以掌握的. 正如毛主席说:\"战略上藐视敌人，战术上重视敌人\".\n\n> 多写才能有所提高, 自己在写韩顺平基础的QQ项目时就写了3遍, 自己独立写完感觉自己对Java的理解提高了一个级别. 韩顺平的JavaWeb家居购物项目我自己也是独立写了一遍, 加深了对JavaWeb的理解. \n \n![photo_2023-05-20_11-07-05.jpg](https://pic.code-nav.cn/post_picture/1608460212774109186/GwpzNWHg-photo_2023-05-20_11-07-05.jpg)\n\n3. `前端框架` 像是Ajax, ES6新特性, vue脚手架. 用来大概2个星期吧. 我主要学习的数据交互方面的知识, 和一些vue基础语法.\n\n\n![photo_2023-05-20_11-22-14.jpg](https://pic.code-nav.cn/post_picture/1608460212774109186/TxpK6ipi-photo_2023-05-20_11-22-14.jpg)\n\n4. 最近一段时间, 在学习`Spring框架`  , 正常记笔记. 到明天应该就可以学习`注解配置`bean了. 一天20多p的进度\n\n### 怎么坚持下来的?\n\n我自己其实是一个很容易放弃的人吧, 之前学习英语很容易就放弃了. 但是我自己对自己非常的狠心. 比如我自己之前很喜欢玩原神, 尤其是高三玩的最严重, 但是我现在碰都不碰了(ps 我不是没有娱乐方式, 我自己是重度二次元看我头像也能猜出来了🤣). 这样我才有很多时间学习`Java`\n\n#### 游戏方面\n\n1. 首先我为什么放弃玩原神(没有说不好玩, 相反就是太好玩了才卸载的)\n+ 非常浪费时间, 升级全靠**概率**.  更重要的是我自己自制力不强, 对于这种诱惑无法克制自己, 经常一玩就是**2,3**个小时, 简直克制不住自己\n2. 戒断的方式\n+ 把原神的手机号换绑到我妈的手机号上面. \n+ 把原神卸载, 这种大型游戏有一个唯一的好处就是卸载之后在下载回来时间成本非常大, 我就懒得下载了.\n\n最近我也把我经常玩的游戏 `荒野乱斗` 注销账号了. 这个是一个小型游戏我自己`经常`下回来玩而且一玩就是`2,3个小时`, 狠狠心我自己卸载了。 自己的娱乐方式就是看看番剧 + 油管视频\n\n#### 短视频方面\n\n短视频我一直都没怎么敢下载, 原因很简单: **太容易获得多巴胺了**, 导致一旦坐下做点复杂的事情就做不了. 所以我不会应该一段时间内不会下载短视频相关的APP. \n\n下面让chatGPT评价一下: 作为一种新兴的媒体形式，短视频具有其独特的优点和魅力。它可以快速地传递信息和内容，让观众在短时间内获得更多的信息和乐趣，同时也为广告主提供了一种全新的宣传方式。\n\n然而，短视频也存在一些问题。由于时长短，往往难以深入探讨某个话题或者表达完整的情感和思想。此外，短视频也容易陷入低俗、娱乐化的泥沼，对社会价值观产生不良影响。\n\n总之，短视频是一种非常流行的媒体形式，但我们需要在充分利用其优点的同时，也认识到其缺点和局限性，并努力提高其质量和价值.\n\n---\n\n自己控制力太差, 直接就卸载了. 而且看视频一般在电脑上看, 这样还可以提醒自己是一个码农\n\n\n#### 学习动力和目标\n\n但是光有时间还不够要有目标和动力, 如果自己没有明确的目标那么可以看看鱼皮的大佬的 https://bcdh.yuque.com/staff-wpxfif/resource/gxn716 帖子. 我现在的短期目标是学完Spring5课程, 长期目标是学完 Java框架, 长期目标是一份工作经济独立. 自己每天也使用微软的 `To Do` 记录自己每一天的目标, 完成打钩√ 成就感爆棚.\n\n如果没有动力的话就去刷刷星球, 看看卷王们的成果, 以此来督促自己的学习, 星球的大佬也是非常多资源也是超级多, 如果不学的话简直亏了(bushi), 资源很多\n\n---\n\n也可以试试`番茄钟` + `番茄todo` , 更加科学的方式效率更高!!! \nhttps://wx.zsxq.com/dweb2/index/topic_detail/181412248518152\n星球官方也有番茄todo的小组 https://wx.zsxq.com/dweb2/index/topic_detail/585521544152854\n\n#### 打卡\n\n每天打卡也是很好的习惯, 每天强迫自己写一点东西(尽管写的很简单🤣), 让自己感觉这一天和昨天有点区别. 如果发现哪里不是很好可以及时更正! 也可以加入一些反思的元素, 反思很重要就比如我今天学习到了Spring的使用 FactoryBean 接口配置Spring中的bean, 然后想着不使用setter方法利用xml的方式找到获取到bean, 结果花了2多小时, 才通过board解决的, 太难了. 下次解决bug没什么思路就先放一放 \n\n### 总结\n\n总之就是前路漫漫还需更加努力!! 希望和球友们一起努力提高自己\n\n', '2023-06-03 19:32:10', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (46, '自我介绍', '本人现在大二，专业软件技术，步入该领域也是在当时没有了解任何专业情况下选的自己感兴趣的专业。\n我是单招进入的大专，在中专的时候就是学的软件技术，毕业时只学到了一些编程的皮毛，在中专实习的时候关注的鱼皮大佬，当时就想以后可以做一个全栈的开发。\n       大一一年基本上都是在上我中专我学过的知识点，除了专业课的时间和上其他基础课的时间，还进了军训团。现在想想浪费了挺多时间，只在大一下学期拿了个蓝桥杯的二等奖。\n       大二一年基本上就是在准备省技能比赛，但是我参加的时VR赛项，至于为什么是参加的VR赛项就不在这里说了，这个比赛是小组赛，一个人负责建模，一个人负责动画，我负责游戏引擎开发，我当时是用的unity进行开发的，值得欣慰的是拿了个省一第一名，可以免试专升本了，现在这个学期还有两个月左右就要去实习，等到大三毕业，我要接着去读本科，我了解到在本科应该是读两年，其中的一年应该也是实习，但是我现在还有MySQL高级的一部分没有学完，JavaScript+jQuery框架刚刚学完，JavaWeb、Spring Cloud微服务应用用开发、Spring MVC企业级程序设计、javaEE数据持久化框架、Vue.js高效前端开发+Ant Design of Vue还没有开始学。\n       目前我还是有点犹豫到底是做我专业的工作，还是Unity游戏开发，如果做Unity游戏开发的话，在下半年我就可以考虑去接着打相关的比赛，但是专升本只能在本省，和大专所学的专业相关的专业去升本，关于unity开发，湖南省应该是没有相对于的专业的。\n       说了这么多，我感觉自己还是想接着去学我自己的专业，Unity游戏开发这个的话，看以后有没有兴趣自己去学吧。但是我现在只有两个月的时间去补我的专业知识了，而且还得去花时间去做毕设，准备实习前的培训，背面试题库，准备简历，累积项目经验，目前为止没有任何项目的经验。\n       现在感觉自己时间非常的紧，感觉自己的时间严重的不够用了。希望自己能撑过这一年吧。\n', '2023-06-03 19:32:13', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (47, 'RPC原理与实现', '\n## 什么是RPC？\n\nRPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。\n\n那么我们至少从这样的描述中挖掘出几个要点：\n\n- RPC是**协议**：既然是协议就只是一套规范，那么就需要有人遵循这套规范来进行实现。目前典型的RPC实现包括：Dubbo、Thrift、GRPC、Hetty等。\n- **网络协议和网络IO模型对其透明**：既然RPC的客户端认为自己是在调用本地对象。那么传输层使用的是TCP/UDP还是HTTP协议，又或者是一些其他的网络协议它就不需要关心了。\n- **信息格式对其透明**：我们知道在本地应用程序中，对于某个对象的调用需要传递一些参数，并且会返回一个调用结果。至于被调用的对象内部是如何使用这些参数，并计算出处理结果的，调用方是不需要关心的。那么对于远程调用来说，这些参数会以某种信息格式传递给网络上的另外一台计算机，这个信息格式是怎样构成的，调用方是不需要关心的。\n- **应该有跨语言能力**：为什么这样说呢？因为调用方实际上也不清楚远程服务器的应用程序是使用什么语言运行的。那么对于调用方来说，无论服务器方使用的是什么语言，本次调用都应该成功，并且返回值也应该按照调用方程序语言所能理解的形式进行描述。\n\n\n![image-20230413134629079.png](https://pic.code-nav.cn/post_picture/1626450481553383425/xfh5e0hA-image-20230413134629079.png)\n\n那要怎样实现透明化远程调用呢？要让开发者无感知的调用远程方法呢？答案就是动态代理！！！\n\n动态代理会通过反射获取到远程服务的接口，当执行本地方法时就会调用`invoke`方法，进行通信相关逻辑，最后成功调用。所以还记得为什么要在进行远程调用的时候消费者和服务者都要定义接口信息，所以**公共模块就可以把Service的接口提取出来**。\n\n### 什么是动态代理\n\n虽然上面说到需要用到动态代理，但是这个玩意儿到底是个啥，所以这里也可以简单聊一聊。\n\n代理其实是一种结构性`设计模式`。可以控制对类对象的访问，在访问类对象时增加额外功能。类似与下图所示，代理会获取到当前接口的实现类，并在其基础上进行增强。\n\n![image-20230413125527475.png](https://pic.code-nav.cn/post_picture/1626450481553383425/X8ceMVbZ-image-20230413125527475.png)\n\n而代理又分为静态代理和动态代理，他们的区分方式是`代理关系是否在编译期确定`。\n\n#### 静态代理\n\n就比如现在想去租房，然后现在只有中介手里才有房源，所以你就可以跟中介进行沟通，而不用去直接和房东沟通。因为在编译期就知道了代理关系，所以是静态代理。通俗的来讲就是你事先知道这个中介是买房子的。\n\n但是静态代理存在一定的缺陷，`重复性`：随着业务的增加需要编写很多模板代码，也就解释了为什么不适用静态代理实现RPC框架。`脆弱性`：一旦基础接口改动，代理类也需要同步修改。\n\n#### 动态代理（通用+兼容多个业务）\n\n同样是中介，只不过这次的中介是拼命三郎，一天打n份工，不仅卖房，还卖车，还卖酒，各种。。。也就是说在联系之前，我们是不知道它卖的是什么？但是见面之后你告诉他需求，他就能帮你找到！是不能提前知道代理关系，所以是动态代理。\n\n动态代理一般有JDK、CGLIB、JavaScript几种实现方式。这里只讨论JDK。它可以利用反射机制在运行时生成的类的字节码，主要是利用Invoke函数去直接访问基础对象，另外也可以通过使用泛型来实现兼容多个业务接口。\n\n对比来看！静态代理就是提前确定一个类，需要把所有的类都提前确定，而动态代理则是可以将类细节隐藏，同时负责多个接口。另外静态代理的类字节码是在编译期就确定的，而动态代理则是在运行时生成的。他们的相同点就是可以不修改原来的对象，只是自己新创建一个对象进行扩展。但重点是控制对于原有对象的访问。\n\n> 这里额外的进行一个扩展，刚刚提到的代理模式，是不是与装饰器模式特别像，至少在功能扩展上是的吧\n> 装饰器模式强调的是增强自身，在被装饰之后你能够在被增强的类上使用增强后的功能。增强后你还是你，只不过能力更强了而已；代理模式强调要让别人帮你去做一些本身与你业务没有太多关系的职责（记录日志、设置缓存）。\n>\n> 1. 代理模式是为了实现对象的控制，因为被代理的对象往往难以直接获得或者是其内部不想暴露出来。\n> 2. 装饰模式是以对客户端透明的方式扩展对象的功能，是继承方案的一个替代方案；代理模式则是给一个对象提供一个代理对象，并由代理对象来控制对原有对象的引用；\n> 3. 装饰模式是为装饰的对象增强功能；而代理模式对代理的对象施加控制，但不对对象本身的功能进行增强；\n\n解释清楚了什么是动态代理，那么中间有提到反射，这又又又是一个技术深入的点。\n\n### 什么是反射\n\n刚才有提到利用反射获取的类的字节码。是的，反射的作用就是在运行时动态的获取类。\n\n在开始之前，先来梳理一下Java的类型模型，首先Java是一个强类型语言，就是变量有固定的类型。另外Java是一个静态语言，即类型检查更偏向于编译时执行，但是也不全部都是，Java有时也会在运行时进行类型检查，比如Object对象的类型检查。\n\n现在想象一下Python在进行变量的创建与接收的时候不用判断类型，同样的，Java通过`反射`也拥有了这样的特性。我们可以直接获取类的对象，进而获取其全部属性。\n\n实质上，反射的实现就是将生成的Class对象直接拿到内存来用，通过Native方法来实现这个过程，而当反射执行次数较多时，通过ASM字节码生成新的类，并将以后的反射委派给新类。\n\n## RPC的实现\n\n讲完了RPC的原理，接下来就是它的实现方式。\n\n常见的几种实现方式包括`grpc` `Thrift` `Dubbo`,这里主要通过DUBBO来实现RPC。官网上是这样说的，提供**高性能通信**和**服务治理**能力的微服务开发框架。\n\n### 高性能通信\n\n#### 高性能数据传输\n\n内置支持Dubbo2、Tripe两个高性能通信协议\n\n- Dubbo2 是基于 TCP 传输协议之上构建的二进制私有 RPC 通信协议，是一款非常简单、紧凑、高效的通信协议\n- Triple 是基于 HTTP/2 的新一代 RPC 通信协议，在网关穿透性、通用性以及 Streaming 通信上具备优势，Triple 完全兼容 gRPC 协议\n\n#### 流式通信\n\n业务的迅速增长会使得集群规模增加，从而带来服务治理问题：\n\n- 注册中心的存储瓶颈\n- 节点动态变化地址推送与解析效率下降\n- 复杂网络链路管理\n\n### 服务治理\n\n#### 流量管控\n\nDubbo 丰富的流量管控规则可以控制服务间的流量走向和 API 调用，基于这些规则可以实现在运行期动态的调整服务行为如超时时间、重试次数、限流参数等，通过控制流量分布可以实现 A/B 测试、金丝雀发布、多版本按比例流量分配、条件匹配路由、黑白名单等，提高系统稳定性。\n\n#### 微服务生态\n\n具有较好的扩展机制，对于大多数服务治理需求都可满足，也可以通过扩展机制轻松适配。\n\nEmmm....感觉框架和应用大致了解一下设计思想，清除一下相关技术替代品，能够在合适的场景下用就好\n\n## Reference\n\n[JDK动态代理的原理其实很简答](https://juejin.cn/post/6974018412158664734)\n\n[反射机制](https://juejin.cn/post/6889833658669072397)\n\n', '2023-06-03 19:32:13', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (48, '代理模式', '一、代理模式介绍\n代理模式在不改变原始代理类的情况下，通过引入代理类来给原始类附加功能。\n代理模式的主要结构如下：\n\n1. Subject：抽象主题类，通过接口或抽象类声明主题和代理对象实现的业务方法\n2. RealSubject：真实主题类，实现Subject中的具体业务，是代理对象所代表的真实对象\n3. Proxy：代理类，其内部含有对真实主题的引用，它可以访问、控制或扩展RealSubject的功能\n4. Client：客户端，通过使用代理类来访问真实的主题类按照上面的类图，可以实现如下代码：\n\n```java\n//主题类接口\npublic interface Subject {\n    void Request();\n}\n\n//真实的主题类\npublic class RealSubject implements Subject{\n\n    @Override\n    public void Request() {\n        System.out.println(\"我是真实的主题类\");\n    }\n}\n\n//代理类\npublic class Proxy implements Subject{\n\n    private RealSubject realSubject;\n\n    @Override\n    public void Request() {\n        if (realSubject == null) {\n            realSubject = new RealSubject();\n        }\n        realSubject.Request();\n    }\n}\n\n//客户端\npublic class Client {\n    public static void main(String[] args) {\n        Proxy proxy = new Proxy();\n        proxy.Request();\n    }\n}\n\n```\n代理模式有比较广泛的使用，比如Spring AOP、RPC、缓存等。在 Java 中，根据代理的创建时期，可以将代理模式分为静态代理和动态代理，下面就来分别阐述。\n\n二、代理模式实现\n动态代理和静态代理的区分就是语言类型是在运行时检查还是在编译期检查。\n\n2.1 静态代理\n\n静态代理是指在编译期，也就是在JVM运行之前就已经获取到了代理类的字节码信息。即Java源码生成.class文件时期。\n由于在JVM运行前代理类和真实主题类已经是确定的，因此也被称为静态代理。\n在实际使用中，通常需要定义一个公共接口及其方法，被代理对象（目标对象）与代理对象一起实现相同的接口或继承相同的父类。\n2.2 动态代理\n\n动态代理，也就是在JVM运行时期动态构建对象和动态调用代理方法。常用的实现方式是反射。反射机制是指程序在运行期间可以访问、检测和修改其本身状态或行为的一种能力，使用反射我们可以调用任意一个类对象，以及其中包含的属性及方法。比如JDK Proxy。\n此外动态代理也可以通过ASM(Java 字节码操作框架)来实现。比如CGLib。\n2.2.1 JDK Proxy\n\n这种方式是JDK自身提供的一种方式，它的实现不需要引用第三方类，只需要实现InvocationHandler接口，重写invoke()方法即可。代码实现如下所示：\n\n```java\npublic class ProxyExample {\n\n    static interface Car {\n        void running();\n    }\n    static class Bus implements Car {\n        @Override\n        public void running() {\n            System.out.println(\"bus is running\");\n        }\n    }\n    static class Taxi implements Car {\n        @Override\n        public void running() {\n            System.out.println(\"taxi is runnig\");\n        }\n    }\n	//核心部分 JDK Proxy 代理类\n    static class JDKProxy implements InvocationHandler {\n        private Object target;\n\n        public Object getInstance(Object target) {\n            this.target = target;\n            //获得代理对象\n            return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), this);\n         }\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            Object result = method.invoke(target, args);\n            return result;\n        }\n    }\n\n    public static void main(String[] args) {\n        JDKProxy jdkProxy = new JDKProxy();\n        Car instance = (Car) jdkProxy.getInstance(new Taxi());\n        instance.running();\n    }\n}\n\n```\n实际上是通过invoke()方法来触发代理的执行方法。最终使得实现Invocation接口的类具有动态代理的能力。动态代理的好处在于不需要和静态代理一样提前写好公共的代理接口，只需要实现Invocation接口就可拥有动态代理能力。\n', '2023-06-03 19:32:13', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (49, 'dubbo 与 openFeign的区别？', 'Dubbo和OpenFeign都是常用的分布式服务框架，它们的主要区别在于以下几点：\n\n1. 服务调用方式不同：Dubbo使用RPC调用，而OpenFeign使用HTTP调用。Dubbo的RPC调用性能更高，而且可以使用多种协议，包括Dubbo协议、HTTP协议等。OpenFeign则是基于HTTP协议的RESTful风格的服务调用框架。\n\n2. 远程服务的管理方式不同：Dubbo的远程服务管理采用的是注册中心，可以对服务进行注册、发现和管理，而OpenFeign则采用HTTP调用方式和服务发现的方式。\n\n3. 使用方式不同：在使用上，Dubbo需要依赖相应的注册中心、协议和其他配置，需要进行比较复杂的配置，OpenFeign则能够通过简单的注解配置即可进行调用和传输。\n\n综上所述，Dubbo更适合于需要高性能、高吞吐量和多协议支持的业务场景，而OpenFeign则更适合于微服务架构下的RESTful风格的服务调用和管理。', '2023-06-03 19:32:13', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (50, 'dubbo是什么？', 'Dubbo是一个高性能、轻量级的开源Java RPC框架。它提供了服务导出与发现、负载均衡、容错、服务治理等基本的核心功能。Dubbo支持多种协议（如dubbo、HTTP、Hessian等）、多种注册中心（如Zookeeper、Redis等）、多种负载均衡策略（如随机、轮询、一致性哈希等）和多种容错机制（如失败自动切换、失败重试等），并支持多种开发语言的调用（如Java、Python、C++等）。\n\nDubbo的优点包括：高性能、可扩展、易于使用、提供完善的服务治理和监控等。它已经被广泛应用于许多大型企业和互联网公司的微服务架构实践中，例如阿里巴巴、京东、美团等等。', '2023-06-03 19:32:13', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (51, 'MySQL主从复制流程', 'MySQL主从复制是一种常用的数据库复制技术，用于实现数据库的高可用性和可伸缩性。下面是MySQL主从复制的基本流程：\n\n1. 配置主数据库（Master）：在主数据库中，需要开启二进制日志功能并设置一个唯一的日志文件名和位置，以便从数据库（Slave）可以下载并应用这些日志。\n\n2. 配置从数据库（Slave）：在从数据库中，需要设置主数据库的IP地址、用户名和密码等信息，以便从数据库可以连接主数据库进行数据复制。同时，需要指定从数据库的唯一标识（如server-id），以确保主从复制的正确性。\n\n3. 启动主从复制：在从数据库中执行\"CHANGE MASTER TO\"命令，设置主数据库IP、用户名、密码等信息，并通过\"START SLAVE\"命令使从数据库连接主数据库并开始复制数据。\n\n4. 数据复制：主数据库将所有更改写入到二进制日志中，从数据库通过读取和解析这些日志文件来复制数据，并在从数据库中应用这些更改。\n\n5. 监控和维护：为了确保主从复制的可靠性，需要对主从数据库进行定期监控和维护，例如检查主从数据库的同步状态、调整网络带宽、备份和恢复数据等。\n\n需要注意的是，MySQL主从复制只适用于单向复制，即主数据库向从数据库的数据复制。如果需要进行双向同步复制，需要使用主主复制或者Galera Cluster等技术。同时，在主从复制中，也需要注意数据一致性和安全性的问题，例如主从数据库的时钟同步、数据加密等。', '2023-06-03 19:32:13', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (52, '最近想做一个将idea中的日志加appium中的日志结合一个网页中的项目（实时获取日志）', '希望各位能推荐数据可视化的项目', '2023-06-03 19:32:13', 0);
INSERT INTO `article` (`id`, `title`, `content`, `createTime`, `isDelete`) VALUES (53, '极简Next.js指南01，想学Next.js的看过来！', '#### 参考文档\n\n- https://www.freecodecamp.org/chinese/news/the-next-js-handbook/#introduction\n- https://www.nextjs.cn/docs/getting-started\n- [https://nextjs.frontendx.cn/docs/#%E7%94%9F%E6%88%90%3Chead%3E](https://nextjs.frontendx.cn/docs/#生成)\n- https://github.com/vercel/next.js\n\n\n#### 优势（相比较其他框架）\n\n- 服务端渲染\n- seo友好\n\n#### next.js基本知识\n\n- 是一个react框架\n- 一个**零配置**，**单指令的react应用工具链 （？？？需要验证）**\n- 提供了一个通用的结构，使你能够轻松地建立一个前端的 React 应用程序，并透明地为你处理服务器端的渲染。**（？？？需要验证）**\n\n#### 主要功能\n\n- Hot Code Reloading（代码热加载）\n\nNext.js 在检测到保存到磁盘的任何变化时，会重新加载页面。\n\n- Automatic Routing（自动路由）\n\n任何 URL 都被映射到文件系统中，映射到放在 pages 文件夹中的文件，你不需要任何配置（当然你有自定义选项）\n\n- Single File Components（单文件组件）\n\n使用`styled-jsx`，完全集成在同一个团队中，为组件添加样式的范围是很简单的。\n\n- Server Rendering（服务器端渲染）\n\n你可以在服务器端渲染 React 组件，然后再将 HTML 发送到客户端。\n\n- Ecosystem Compatibility（生态系统的兼容性）\n\nNext.js 与 JavaScript、Node 和 React 生态系统的其他部分配合良好。\n\n- Automatic Code Splitting（自动代码拆分）\n\n渲染页面时，只需使用它们需要的库和 JavaScript，而无需其他。Next.js 不会生成一个包含所有应用程序代码的单一 JavaScript 文件，而是将应用程序自动分解为几个不同的资源。\n\n加载一个页面只加载该特定页面所需的 JavaScript。\n\nNext.js 通过分析导入的资源来做到这一点。\n\n例如，如果你只有一个页面导入了 Axios 库，那么这个特定的页面将在打包（bundle）的时候包含该库。\n\n这可以确保你的第一个页面加载速度尽可能快，而且只有未来的页面加载（如果它们将被触发）才会向客户端发送所需的 JavaScript。\n\n有一个值得注意的例外。如果经常使用的导入程序在网站页面中至少有一半被使用，它们就会被打包到主 JavaScript 中。\n\n- Prefetching（预取）\n\n用于连接不同页面的 Link 组件支持 prefetch prop ，在后台自动预取页面资源（包括因代码分割而丢失的代码）。\n\n- Dynamic Components（动态组件）\n\n你可以动态地导入 JavaScript 模块和 React 组件。\n\n- Static Exports（静态导出）\n\n使用next export命令，Next.js 允许你从你的应用程序导出一个完全静态的网站。\n\n- TypeScript Support（支持 TypeScript）\n\nNext.js 是用 TypeScript 编写的，因此，它具有出色的 TypeScript 支持。\n\n### Next.js 学习\n\n#### 1. 新建一个next.js项目\n\n确保在安装next.js项目之前，你的环境有node.js。node,js自带npm，所有安装好node.js，我们的环境就ok了\n\n##### 安装方法： \n\n1. 使用`create-next-app`,\n2. 传统方法，手动安装和设置\n\n##### 先说使用脚手架的方法\n\n我们可以把`create-next-app`当成 `create-next-app`；或者Vue中的`create-vue`；我们直接打开终端运行`npx create-next-app`,脚手架会帮我们新建一个文件夹，并下载项目所需要的包，下载完成后，我们运行`npm run dev`，并在游览器打开`http://localhost:3000`即可看见下面页面：\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/UIujXwuP-image.png)\n\n如果跟着`freeCodeCamp`学习的，可以知道我们可以下载一些额外的代码，更加快速的搭建自己的项目，命令为`npx create-next-app --example blog-starter` 其中`blog-starter`为可变的，具体可看这个仓库`https://github.com/vercel/next-learn`\n\n##### 手动创建（0->1）\n\n1. 创建一个文件夹，存放你的`next.js`应用程序\n2. `npm init -y`初始化一个新的node.js项目，`-y`是 `-yes`，告诉`npm`项目使用默认配置，生成一个模板文件`package.json`。\n3. 安装`Next` 和 `React`：`npm install next react react-dom` (如果你还没有喜欢的编辑器，我推荐使用VSCode, 对新人友好，简单，WebStorm也是很好的选择)\n4. 修改脚本(`scripts`) 部分\n\n```javascript\n\"scripts\": {\n  \"dev\": \"next\",\n  \"build\": \"next build\",\n  \"start\": \"next start\"\n}\n// \"dev\": \"next -p 3001\", 这样写，我们的项目启动端口号就是3001\n```\n\n1. 创建一个`pages`文件夹，并添加一个`index.js`文件。\n\n```javascript\nconst Index = () => (\n  <div>\n    <h1>Home page</h1>\n  </div>\n)\n\nexport default Index\n```\n\n1. 使用终端，运行 npm run dev 来启动 Next 开发服务器\n\n#### 2. 验证next.js是SSR的工作方式\n\n**SSR:( 服务器端渲染**`**server side rendered**` **)** ,是一个做门户网站非常好的特性，因为：如果我们使用 Next.js 创建一个网站，网站页面会在服务器上渲染，而服务器会将 HTML 传递给浏览器，具体的优点有三个：\n\n- 客户端不需要实例化 React 来渲染，这使得**网站对你的用户来说更快**。\n- **搜索引擎会对页面进行索引**，而不需要运行客户端的 JavaScript。谷歌开始解决这个问题（客户端渲染），但公开承认是一个较慢的过程（如果你想获得好的排名，你应该尽可能地帮助谷歌）。\n- **你可以有社交媒体元标签**，对添加预览图片，为你在 Facebook、Twitter 上分享的任何页面定制标题和描述都很有用。\n\n验证的方式非常简单：我们右键我们的next.js应用，查看网站源代码，我们可以看到下面这些代码\n\n```html\n<!DOCTYPE html>\n<html>\n<head>\n  <style data-next-hide-fouc=\"true\">\n    body {\n      display: none\n    }\n  </style><noscript data-next-hide-fouc=\"true\">\n    <style>\n      body {\n        display: block\n      }\n    </style>\n  </noscript>\n  <meta charSet=\"utf-8\" />\n  <meta name=\"viewport\" content=\"width=device-width\" />\n  <title>Create Next App</title>\n  <meta name=\"description\" content=\"Generated by create next app\" />\n  <link rel=\"icon\" href=\"/favicon.ico\" />\n  <meta name=\"next-head-count\" content=\"5\" /><noscript data-n-css=\"\"></noscript>\n  <script defer=\"\" nomodule=\"\" src=\"/_next/static/chunks/polyfills.js?ts=1668608244862\"></script>\n  <script src=\"/_next/static/chunks/webpack.js?ts=1668608244862\" defer=\"\"></script>\n  <script src=\"/_next/static/chunks/main.js?ts=1668608244862\" defer=\"\"></script>\n  <script src=\"/_next/static/chunks/pages/_app.js?ts=1668608244862\" defer=\"\"></script>\n  <script src=\"/_next/static/chunks/pages/index.js?ts=1668608244862\" defer=\"\"></script>\n  <script src=\"/_next/static/development/_buildManifest.js?ts=1668608244862\" defer=\"\"></script>\n  <script src=\"/_next/static/development/_ssgManifest.js?ts=1668608244862\" defer=\"\"></script><noscript\n    id=\"__next_css__DO_NOT_USE__\"></noscript>\n</head>\n\n<body>\n  <div id=\"__next\">\n    <div class=\"Home_container__bCOhY\">\n      <main class=\"Home_main__nLjiQ\">\n        <h1 class=\"Home_title__T09hD\">Welcome to <a href=\"https://nextjs.org\">Next.js!</a></h1>\n        <p class=\"Home_description__41Owk\">Get started by editing\n          <!-- --> <code class=\"Home_code__suPER\">pages/index.tsx</code>\n        </p>\n        <div class=\"Home_grid__GxQ85\"><a href=\"https://nextjs.org/docs\" class=\"Home_card___LpL1\">\n            <h2>Documentation →</h2>\n            <p>Find in-depth information about Next.js features and API.</p>\n          </a><a href=\"https://nextjs.org/learn\" class=\"Home_card___LpL1\">\n            <h2>Learn →</h2>\n            <p>Learn about Next.js in an interactive course with quizzes!</p>\n          </a><a href=\"https://github.com/vercel/next.js/tree/canary/examples\" class=\"Home_card___LpL1\">\n            <h2>Examples →</h2>\n            <p>Discover and deploy boilerplate example Next.js projects.</p>\n          </a><a\n            href=\"https://vercel.com/new?utm_source=create-next-app&amp;utm_medium=default-template&amp;utm_campaign=create-next-app\"\n            target=\"_blank\" rel=\"noopener noreferrer\" class=\"Home_card___LpL1\">\n            <h2>Deploy →</h2>\n            <p>Instantly deploy your Next.js site to a public URL with Vercel.</p>\n          </a></div>\n      </main>\n      <footer class=\"Home_footer____T7K\"><a\n          href=\"https://vercel.com?utm_source=create-next-app&amp;utm_medium=default-template&amp;utm_campaign=create-next-app\"\n          target=\"_blank\" rel=\"noopener noreferrer\">Powered by\n          <!-- --> <span class=\"Home_logo__27_tb\"><img alt=\"Vercel Logo\" srcSet=\"/vercel.svg 1x, /vercel.svg 2x\"\n              src=\"/vercel.svg\" width=\"72\" height=\"16\" decoding=\"async\" data-nimg=\"1\" loading=\"lazy\"\n              style=\"color:transparent\" /></span>\n        </a></footer>\n    </div>\n  </div>\n  <script src=\"/_next/static/chunks/react-refresh.js?ts=1668608244862\"></script>\n  <script id=\"__NEXT_DATA__\"\n    type=\"application/json\">{\"props\":{\"pageProps\":{}},\"page\":\"/\",\"query\":{},\"buildId\":\"development\",\"nextExport\":true,\"autoExport\":true,\"isFallback\":false,\"scriptLoader\":[]}</script>\n</body>\n\n</html>\n```\n\n可以看到这是一个html网页\n\n#### 3. 安装 React DevTools\n\nNext.js 是基于 React 的，所以我们绝对需要安装一个非常有用的工具（如果你还没有），那就是 React 开发者工具（React Developer Tools\n\n安装成功之后，我们打开`F12`可以看见新增了两个\n\n![img](https://cdn.nlark.com/yuque/0/2022/png/21765913/1668608585453-1c99947b-7c5b-4e52-a100-da13fe8b55fa.png)\n\n它的具体使用可参考[手册](https://www.freecodecamp.org/chinese/news/the-next-js-handbook/#the-app-bundles)的对应部分讲解\n\n#### 4. 给网站添加第二页\n\n非常简单，\n\n1. 在`pages`目录下，新建一个文件，要以`.js .ts .tsx`等结尾，文件名就是路由名称\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/X1I8iTrg-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/kEljTksg-image.png)\n\n- 如果你正在做这一步，你会惊奇的发现，它是热更新的，\n- 如果你喜欢专研，当你查看源代码，你会发现它有类似这种`/_next/static/chunks/pages/new.js?ts=1668609323024`,但是没有主页的`/_next/static/chunks/pages/index.js?ts=1668609366382`这也就验证了，`next.js`的自动代码分包的能力 👍👍👍\n\n#### 5. 链接两个页面\n\n我们可以使用最简单的a标签实现\n\n```html\n<a href=\"/blog\">Blog</a>\n```\n\n但是，我们不能这样做，因为你使用了`next.js`,你可以有更好的方式来实现它\n\n使用 Next 的主要好处之一是，一旦一个页面被加载，由于客户端的渲染，过渡到其他页面的速度非常快。\n\n当我们使用a标签，第一次加载时候，我们得到了所有加载页面的bundles，当我们点击链接，我们又从服务器得到了**所有的JavaScript**，**这样是不合理的**，因为我们已经得到了所有的JavaScript，我们只需要新进来的这个页面的bundle,\n\n**为了解决这个问题**，`next.js`提供了一个组件叫，`Link`,我们现在体验一下，\n\n```javascript\nimport Link from \'next/link\' // 先导入它\n```\n\n然后我们把它当做我们的`a`标签使用，像这样 👇 👇 \n\n```javascript\n<Link href=\"/\">go to home</Link>\n```\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/EuYDDSir-image.png)\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/WPeG0eeU-image.png)\n\n如果你正在做，你会发现，现在只会再请求一个`new.js`,如果你在这个页面有一个返回按钮，你会发现它不会再次请求任何文件，而且页面的加载速度比以前快了很多，这就是客户端渲染的作用。\n\n#### 6. 路由与动态内容\n\n博客是`next.js`很好的一个使用场景，在博客中有一个非常常见的页面，就是博客文章，文章的样式是固定的，内容是不同的，通过一个动态的URL来判断，不同的URL对应着不同的内容，内容可能取自数据库，也可能是Markdown文档**，Next.js 可以根据一个\\**dynamic URL(动态 URL)\\**来提供动态内容。**具体实现 👇 👇 \n\n1. 通过使用`[]`语法创建一个动态页面来创建一个动态 URL。\n2. 如何创建？我们添加一个`pages/blog/[id].js`文件。这个文件将处理`/blog/`路径下的所有动态 URL\n3. 方括号内的`[id]`意味着任何动态的东西都将被放在 **路由的查询属性（query property）**的id参数中。\n\n划重点⭐️ ⭐️ ⭐️ \n\n这里可能有帅气的小伙伴会问，什么是路由？？\n\n- 路由(router)是 Next.js 提供的一个库。\n- 我们从 next/router 导入它`import { useRouter } from \'next/router\'`\n- 我们有了useRouter，我们就用useRouter来实例化路由对象:`const router = useRouter()`\n- 有了这个路由对象，我们就可以从中提取信息\n- 我们可以通过访问`router.query.id`来获得`[id].js`文件中 URL 的动态部分。\n- 动态部分也可以只是 URL 的一部分，如`post-[id].js`。\n- 让我们`code a demo`\n\n```javascript\n// 创建文件pages/blog/[id].js\nimport { useRouter } from \'next/router\'\n// import \'../blog/blog\'\nexport default () => {\n  const router = useRouter()\n  return (\n    <div className=\'box\'>\n      <h1>Blog Context</h1>\n      <h3>Time: 2022-11-20</h3>\n      <div>\n        <span>Post id: &nbsp;&nbsp;&nbsp;{router.query.id}</span>\n        <br />\n        今天也有认真的学习，认真的生活，嘿嘿！！！<br />\n        😆 😊 😃 😏 😍 😘 😚 😳 😌 😆 😁 😉 😜 😝 😀 😗 😙 😛<br />\n        💙 💜 ❤️ 💚 💔 💓 💗 💕 💞 💘 💖 ✨ ⭐️ 🌟 <br />\n        🙋 👰 🙎 🙍 🙇 💑 💆 💇 <br />\n        🐭 🐹 🐰 🐺 🐸 🐯 🐨 🐻 🐷 🐽 🐮<br />\n      </div>\n    </div>\n  )\n}\n```\n\n- 这样我们就可以去`http://localhost:3000/blog/test`路由,其中test可以替换为任意字符，它就是我们接收到的id\n- 那么我们就可以使用这个id作为参数，从一个帖子列表中收集帖子，例如，从一个`JSON`数据库中获取帖子数据，看下面 👇 👇 \n\n们将在项目根目录下添加一个posts.json文件\n\n```json\n{\n  \"test\": {\n    \"title\": \"test post\",\n    \"content\": \"Hey some post content\"\n  },\n  \"second\": {\n    \"title\": \"second post\",\n    \"content\": \"Hey this is the second post content\"\n  }\n}\n```\n\n现在我们可以导入它，并从id键中查找帖子:\n\n```tsx\nimport { useRouter } from \'next/router\'\nimport posts from \'../../posts.json\'\n\nexport default () => {\n  const router = useRouter()\n\n  const post = posts[router.query.id]\n\n  return (\n    <>\n      <h1>{post.title}</h1>\n      <p>{post.content}</p>\n    </>\n  )\n}\n```\n\n我们是不是就可以根据id获取数据库（JSON对象）中对应的内容了呢？？\n\n结果是报错了👿👿👿\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/eena7Ygn-image.png)\n\n为什么呢？因为在渲染过程中，当组件被**初始化**时，数据还不在那里。后面会用 **getInitialProps** 向组件提供数据。\n\n虽然解决了这个问题，但它不能实现 SSR，这既损害了用户的加载时间，也损害了 SEO 和社交分享\n\n#### 7. Prefetching\n\n我们使用Link 组件可以用来创建 2 个页面之间的链接，当你使用它时，**Next.js 会透明地为我们处理前端路由**，所以当用户点击一个链接时，前端会负责显示新的页面，而不会像通常网页那样触发新的客户/服务器请求和响应周期。\n\n而且，只要是被`Link`标签包裹的元素出现在视口（viewport）中，Next.js 就会预取(prefetch)它所指向的 URL，只要它是一个本地链接（在你的网站上），就会使应用程序对浏览者来说超级快速。但是这种行为只在生产模式下被触发，这意味着如果你用`npm run dev`运行应用程序，你必须停止它，用`npm run build`编译你的生产包，用`npm run start`运行它。\n\n**注意**： 当页面加载时，任何再折叠上方的链接都会在你的页面触发`load`事件（当页面完全加载时触发，发生在DOMContentLoaded事件之后）时开始预取（prefetch），任何不在视口（viewport）中的其他链接标签将被预取，当用户滚动到它是，它会被预取，预取在高速连接（Wifi 和 3g 以上连接）是自动的，除非浏览器发送 [Save-Data HTTP Header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Save-Data)。\n\n**可以通过设置 prefetch prop 为 false来选择不预取单个 Link 实例**\n\n```javascript\n<Link href=\"/a-link\" prefetch={false}>\n  <a>A link</a>\n</Link>\n```\n\n#### 8. 使用路由器来检测活动链接\n\n在处理链接时，一个非常重要的功能是确定什么是当前的 URL，特别是给活动链接分配一个类别，这样我们就可以使它的样式与其他的不同。我们需要使用的是`next.js`提供的`next/link`\n\n#### 9. 使用 next/router\n\n我们现在已经可以使用`Link`组件声明式的处理`Next.js`中的路由跳转，有时候我们还需要捕获当前路由信息或者编程式的触发路由变化，我们可以使用`useRouter`实例，调用其`push`方法，进行路由的切换，\n\n**注意：**这是客户端的路由，所以方法应该只在面向前端的代码中使用。确保这一点的最简单方法是在useEffect() React hook 中调用，或在componentDidMount()中调用 React 有状态组件\n\n我们最常使用的有俩个API：`push()`和`preFetch()`\n\n- push()允许我们在前端以编程方式触发 URL 变化。:` router.push(\'/login\')`\n- prefetch()允许我们以编程方式预取（prefetch）一个 URL，当我们没有自动处理预取的Link标签时很有用:`router.prefetch(\'/login\')`\n- 也可以使用路由来监听 [路由变更事件](https://nextjs.org/docs#router-events)。\n\n#### 10 .使用 getInitialProps() 向组件提供数据\n\n还记得前面，我们动态生成帖子，初始数据没有的问题吗？？😫😫因为该组件需要一些前期的数据，我们试图从 JSON 文件中获取数据时；我们页面报错了\n\n如何解决报错？又如何使SSR工作于动态路由？\n\n答：我们必须为组件提供 props，使用一个名为 getInitialProps() 的特殊函数，它被附加到组件上，具体实现步骤如下👇 👇 \n\n- 首先，我们要为该组件命名，例如这样：`export default function Content (){}`\n- 然后，我们为该函数添加属性，`Post.getInitialProps = () => {}`\n- 现在，这个函数可以得到一个对象作为其参数，参数包含有几个属性，其中，就包含我们的`query`对象，也就是我们之前得到帖子ID的对象`Post.getInitialProps = ({query}) => {}`\n- 我们可以从这个函数中返回帖子：\n\n```javascript\nPost.getInitialProps = ({ query }) => {\n  return {\n    post: posts[query.id]\n  }\n}\n```\n\n- 我们这个时候可以删除`useRouter`的导入，我们可以从`getInitialProps`中获得当前路由信息\n\n**关于getInitialProps**\n\n- `getInitialProps`函数将在服务器端执行，但也会在客户端执行\n- `getInitialProps `在它收到的上下文对象(`context object `)中，除了query对象外，还得到了其他的属性\n\n- - `pathname:` URL 的 path 部分\n  - `asPath` - 浏览器中显示的实际路径（包括查询 query）的字符串\n\n如果你做过Node.js编程，你还需要知道。虽然我不知道它在说什么😜😜😜\n\n\n![image.png](https://pic.code-nav.cn/post_picture/1619930914211520514/ynJsSe5O-image.png)\n\n#### 11. CSS\n\n选择什么CSS方案是非常重要的，它决定了我们写css代码的方式\n\n我们有很大的自由度，因为我们可以使用任何我们喜欢的库。\n\n但 Next.js 内置了[styled-jsx](https://github.com/vercel/styled-jsx)，因为那是由维护 Next.js 的人建立的一个库。\n\n使用方法非常简单，在JSX的一个片段中插入它，最小实例为\n\n```jsx\n<div className=\'test\'>哈哈哈哈</div>\n<style jsx>{`\n  .test{\n    background: pink;\n  }\n`}</style>\n```\n\n你以为这就完了吗？还有更厉害的\n\n```jsx\nconst Index = props => (\n  <div>\n  <h1>Home page</h1>\n\n  <style jsx>{`\n    h1 {\n      font-size: ${props.size}rem;\n    }\n  `}</style>\n  </div>\n)\n<style jsx global>{`\nbody {\n  margin: 0;\n}\n`}</style>\n```\n\n但是它也有不足的地方，如果你需要引入一个外部的css文件，你必须先安装`@zeit/next-css`（已弃用）\n\n```tsx\n// 先引入依赖\nnpm install @zeit/next-css\n// 然后在项目根目录，创建一个文件next.config.ts，这种写\nimport withCSS from \'@zeit/next-css\'\nmodule.exports = withCSS()\n```\n\n##### 现在推荐如下使用方式\n\n参考文档：https://nextjs.org/docs/basic-features/built-in-css-support\n\n- 全局的话，需要创建.css文件写入需要的样式，然后导入到pages/_app.js中\n- 从node_modules导入样式\n\n```javascript\n// pages/_app.js\nimport \'bootstrap/dist/css/bootstrap.css\'\nimport \'@reach/dialog/styles.css\'\nexport default function MyApp({ Component, pageProps }) {\n  return <Component {...pageProps} />\n}\n```\n\n- 对于组件（页面）级的，添加CSS方式\n\n支持使用 [name].module.css 文件命名约定的 [CSS 模块](https://github.com/css-modules/css-modules)，CSS 模块通过自动创建唯一的类名来本地限定 CSS 的范围。这允许您在不同的文件中使用相同的 CSS 类名，而不必担心冲突。此行为使 CSS 模块成为包含组件级 CSS 的理想方式。CSS 模块文件**可以导入应用程序中的任何位置**.\n\n- 也支持sass\n\n允许您使用 .scss 和 .sass 扩展名导入 Sass。您可以通过 CSS 模块和 .module.scss 扩展名使用组件级 .module.sass。但是在此之前需要安装sass：`npm install --save-dev sass`\n\nSass 支持与上面详述的内置 CSS 支持具有相同的优点和限制。\n\n**注意**：Sass 支持[两种不同的](https://sass-lang.com/documentation/syntax)语法，每种语法都有自己的扩展名。..scss扩展名要求您使用[SCSS](https://sass-lang.com/documentation/syntax#scss)语法，而.sass扩展名要求您使用[缩进语法（“Sass”）](https://sass-lang.com/documentation/syntax#the-indented-syntax).\n\n#### 12. 添加一个封装组件\n\n我们想要使用这个项目，实现我们的想法，我们会发现，会有很多页面的结构都差不多，\n\n我们可以使用组件来复用\n\n#### 13. API Routes\n\n除了创建 页面路由（page routes），也就是将页面作为网页提供给浏览器之外，Next.js 还可以创建 API 路由（API routes）。API 路由也可以像页面一样使用 **动态路由**\n\n#### 14. 在服务器端，或在客户端运行代码\n\n在你的页面组件中，你可以通过检查window属性，判断在服务器端或在客户端执行代码。\n\n```javascript\ntypeof window !== \'undefined\'\n// true代表客户端；false代表服务端\n```\n\n### end . conception\n\n#### 简约\n\n参考实例：\n\n- http://www.liuweibo.cn/p/206#heading-11\n- 个人介绍：https://eveningwater.github.io/my-web-projects/website/index.html\n\n#### 链接语雀文档\n\n\n\n#### 博客主页参考文章：\n\n1. https://developer.aliyun.com/article/999730\n2. https://developer.aliyun.com/article/805442#slide-1\n3. [https://raoenhui.github.io/nextjs/2018/08/31/Nextjs%E4%B8%AD%E6%96%87%E6%96%87%E6%A1%A3/#fetching-data-and-component-lifecycle](', '2023-06-03 19:32:13', 0);
